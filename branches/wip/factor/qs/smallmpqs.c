/*----------------------------------------------------------------------
This source distribution is placed in the public domain by its author,
Ben Buhrow. You may use it for any purpose, free of charge,
without having to notify anyone. I disclaim any responsibility for any
errors.

Optionally, please be nice and tell me if you find this source to be
useful. Again optionally, if you add to the functionality present here
please consider making those additions public too, so that others may 
benefit from your work.	

Some parts of the code (and also this header), included in this 
distribution have been reused from other sources. In particular I 
have benefitted greatly from the work of Jason Papadopoulos's msieve @ 
www.boo.net/~jasonp, Scott Contini's mpqs implementation, and Tom St. 
Denis Tom's Fast Math library.  Many thanks to their kind donation of 
code to the public domain.
       				   --bbuhrow@gmail.com 11/24/09
----------------------------------------------------------------------*/

#include "yafu.h"
#include "factor.h"
#include "soe.h"
#include "util.h"
#include "common.h"
#include <gmp.h>
#include "gmp_xface.h"

#define SM_BLOCKSIZE 16384

typedef struct
{
	uint32 prime_and_logp;
	uint32 roots;					//root1 is stored in the lower 16 bits, root2 in the upper 16
} smpqs_sieve_fb;

typedef struct
{
	uint32 small_limit;
	uint32 num_blocks;
	uint32 large_mult;
	double fudge_factor;
	uint32 num_extra_relations;
	uint32 dlp_lower;
	uint32 dlp_upper;
	int in_mem;
	int use_dlp;
} sm_mpqs_params;

//holds all the info for a factor base element
typedef struct
{
	uint16 *prime;	
	uint16 *logprime;
    uint32 *small_inv;
    uint16 *proot1;
    uint16 *proot2;
    uint16 *nroot1;
    uint16 *nroot2;
} fb_element_sm_mpqs;

typedef struct
{
	uint32 B;
	uint32 small_B;
	uint32 med_B;
	fb_element_sm_mpqs *list;
} fb_list_sm_mpqs;

typedef struct
{
	mpz_t polyb;				//which polyb this relation uses
	uint32 largeprime;		//large prime in the pd.
	uint32 offset;			//offset specifying Q (the quadratic polynomial)
	uint32 polynum;			//which poly this relation uses
	uint32 parity;			//the sign of the offset (x) 0 is positive, 1 is negative
	uint16 *fboffset;		//offsets of factor base primes dividing Q(offset).  max # of fb primes < 2^16 with this choice
	uint8 num_factors;		//number of factor base factors in the factorization of Q
} sm_mpqs_r;

typedef struct
{
	uint32 num_r;
	uint32 act_r;
	uint32 allocated;
	sm_mpqs_r **list;
} sm_mpqs_rlist;

typedef struct
{
	uint64 poly_a;
	uint64 poly_b;
	mpz_t poly_c;
	uint32 poly_d;
	int poly_d_idp;
	int poly_d_idn;
	int side;
	int use_only_p;
} sm_mpqs_poly;

static void smpqs_sieve_block(uint8 *sieve, smpqs_sieve_fb *fb, uint32 start_prime, 
	uint8 s_init, fb_list_sm_mpqs *fullfb);

static int smpqs_check_relations(uint32 sieve_interval, uint32 blocknum, uint8 sieve[] ,mpz_t n, 
								sm_mpqs_poly *poly, uint8 closnuf,
								smpqs_sieve_fb *fb,fb_list_sm_mpqs *fullfb, sm_mpqs_rlist *full, 
								sm_mpqs_rlist *partial, uint32 cutoff,
								uint8 small_cutoff, uint32 start_prime, uint32 parity, 
								uint32 *num, int numpoly);

static void smpqs_trial_divide_Q(mpz_t Q, smpqs_sieve_fb *fb, sm_mpqs_rlist *full, sm_mpqs_rlist *partial,
						  uint8 *sieve, uint32 offset, uint32 j, uint32 sign, fb_list_sm_mpqs *fullfb, 
						  uint32 cutoff, uint8 small_cutoff, uint32 start_prime, int numpoly, 
						  uint32 parity, uint8 closnuf, uint8 bits);

static void smpqs_save_relation(sm_mpqs_rlist *list, uint32 offset, uint32 largeprime, uint32 num_factors, 
						  uint32 rnum, uint16 *fboffset, int numpoly, uint32 parity);

void smpqs_make_fb_mpqs(fb_list_sm_mpqs *fb, uint32 *modsqrt, mpz_t n);
void smpqs_computeB(sm_mpqs_poly *poly, mpz_t n);
void smpqs_nextD(sm_mpqs_poly *poly, mpz_t n);
void smpqs_computeRoots(sm_mpqs_poly *poly, fb_list_sm_mpqs *fb, uint32 *modsqrt, 
	smpqs_sieve_fb *fbp, smpqs_sieve_fb *fbn, uint32 start_prime);

void smpqs_get_more_primes(sm_mpqs_poly *poly);
uint8 smpqs_choose_multiplier(mpz_t n, uint32 fb_size);
int smpqs_BlockGauss(sm_mpqs_rlist *full, sm_mpqs_rlist *partial, uint64 *apoly, uint64 *bpoly,
			fb_list_sm_mpqs *fb, mpz_t n, int mul, 
			mpz_t *factors, uint32 *num_factor);
int sm_check_relation(mpz_t a, mpz_t b, sm_mpqs_r *r, fb_list_sm_mpqs *fb, mpz_t n);

__inline void sm_zcopy(mpz_t src, mpz_t dest)
{
	mpz_set(dest, src);
}

void sm_get_params(int bits, uint32 *B, uint32 *M, uint32 *BL);
int qcomp_smpqs(const void *x, const void *y);



uint32 small_inv_tab[1000][3] = { { 2147483648, 1, 1 },
{ 1431655765, 1, 2 },
{ 858993459, 1, 2 },
{ 613566757, 0, 3 },
{ 390451572, 1, 3 },
{ 330382100, 0, 4 },
{ 252645135, 1, 4 },
{ 226050910, 1, 4 },
{ 186737709, 0, 5 },
{ 148102321, 0, 5 },
{ 138547332, 1, 5 },
{ 116080197, 1, 5 },
{ 104755300, 0, 5 },
{ 99882960, 1, 5 },
{ 91382283, 0, 6 },
{ 81037119, 0, 6 },
{ 72796056, 0, 6 },
{ 70409300, 0, 6 },
{ 64103989, 1, 6 },
{ 60492497, 1, 6 },
{ 58835168, 1, 6 },
{ 54366675, 0, 6 },
{ 51746594, 0, 6 },
{ 48258060, 0, 6 },
{ 44278013, 1, 7 },
{ 42524429, 0, 7 },
{ 41698712, 0, 7 },
{ 40139881, 1, 7 },
{ 39403370, 0, 7 },
{ 38008560, 1, 7 },
{ 33818640, 1, 7 },
{ 32786010, 0, 7 },
{ 31350126, 1, 7 },
{ 30899045, 1, 7 },
{ 28825284, 0, 7 },
{ 28443492, 1, 7 },
{ 27356480, 0, 7 },
{ 26349493, 0, 7 },
{ 25718367, 1, 7 },
{ 24826401, 0, 7 },
{ 23994231, 0, 7 },
{ 23729101, 1, 7 },
{ 22486740, 0, 8 },
{ 22253717, 0, 8 },
{ 21801864, 1, 8 },
{ 21582750, 1, 8 },
{ 20355295, 1, 8 },
{ 19259943, 1, 8 },
{ 18920561, 0, 8 },
{ 18755316, 0, 8 },
{ 18433336, 1, 8 },
{ 17970574, 1, 8 },
{ 17821441, 1, 8 },
{ 17111423, 1, 8 },
{ 4278255361, 0, 8 },
{ 4180652577, 1, 8 },
{ 4087403821, 0, 8 },
{ 4057238479, 0, 8 },
{ 3969356057, 0, 8 },
{ 3912852768, 0, 8 },
{ 3885200098, 1, 8 },
{ 3752599412, 1, 8 },
{ 3581471100, 1, 8 },
{ 3535407163, 1, 8 },
{ 3512816702, 1, 8 },
{ 3468490939, 1, 8 },
{ 3321787395, 1, 8 },
{ 3262645780, 0, 8 },
{ 3168621406, 0, 8 },
{ 3150463117, 0, 8 },
{ 3114763818, 1, 8 },
{ 3062706484, 1, 8 },
{ 2995944490, 0, 9 },
{ 2947752353, 1, 9 },
{ 2901086089, 1, 9 },
{ 2870787540, 0, 9 },
{ 2826508041, 0, 9 },
{ 2769550700, 0, 9 },
{ 2741924259, 0, 9 },
{ 2688292488, 1, 9 },
{ 2624132763, 1, 9 },
{ 2611666574, 1, 9 },
{ 2551071062, 1, 9 },
{ 2539287824, 0, 9 },
{ 2504582296, 0, 9 },
{ 2481967557, 1, 9 },
{ 2448800953, 0, 9 },
{ 2405933540, 0, 9 },
{ 2385057761, 0, 9 },
{ 2374755136, 0, 9 },
{ 2354414621, 0, 9 },
{ 2295431373, 1, 9 },
{ 2257724082, 0, 9 },
{ 2239331217, 1, 9 },
{ 2203430116, 0, 9 },
{ 2185907809, 0, 9 },
{ 2160140723, 0, 9 },
{ 2110387001, 1, 9 },
{ 2102316688, 0, 9 },
{ 2032368998, 0, 9 },
{ 2010076102, 0, 9 },
{ 1973988560, 0, 9 },
{ 1952951381, 1, 9 },
{ 1932357870, 0, 9 },
{ 1925589541, 0, 9 },
{ 1905566079, 1, 9 },
{ 1873103284, 1, 9 },
{ 1854151143, 0, 9 },
{ 1835578677, 1, 9 },
{ 1829470263, 0, 9 },
{ 1811386537, 0, 9 },
{ 1793656815, 1, 9 },
{ 1782028570, 1, 9 },
{ 1776270804, 1, 9 },
{ 1742490694, 0, 9 },
{ 1715306752, 0, 9 },
{ 1709971427, 1, 9 },
{ 1699399734, 0, 9 },
{ 1683785035, 0, 9 },
{ 1668454670, 1, 9 },
{ 1663406396, 1, 9 },
{ 1633746847, 0, 9 },
{ 1624093985, 0, 9 },
{ 1609826688, 0, 9 },
{ 1591189042, 0, 9 },
{ 1568490197, 0, 9 },
{ 1550792141, 0, 9 },
{ 1529223404, 1, 9 },
{ 1512395637, 0, 10 },
{ 1500015863, 1, 10 },
{ 1487837115, 0, 10 },
{ 1479827224, 1, 10 },
{ 1464063419, 1, 10 },
{ 1452459218, 0, 10 },
{ 1444824741, 0, 10 },
{ 1429794054, 1, 10 },
{ 1422395379, 0, 10 },
{ 1397092284, 1, 10 },
{ 1379562896, 0, 10 },
{ 1359099664, 0, 10 },
{ 1355748000, 0, 10 },
{ 1339234626, 0, 10 },
{ 1335980107, 0, 10 },
{ 1329518292, 1, 10 },
{ 1326310769, 1, 10 },
{ 1310502536, 1, 10 },
{ 1288993702, 0, 10 },
{ 1282977395, 1, 10 },
{ 1279990254, 0, 10 },
{ 1274057506, 1, 10 },
{ 1253719074, 0, 10 },
{ 1248026819, 1, 10 },
{ 1245200031, 1, 10 },
{ 1239584699, 0, 10 },
{ 1212250968, 0, 10 },
{ 1206928241, 1, 10 },
{ 1196421793, 1, 10 },
{ 1183543195, 0, 10 },
{ 1173438237, 0, 10 },
{ 1168450189, 0, 10 },
{ 1161047125, 1, 10 },
{ 1153737280, 0, 10 },
{ 1137033741, 1, 10 },
{ 1132349771, 1, 10 },
{ 1125395730, 0, 10 },
{ 1118526580, 0, 10 },
{ 1109497102, 0, 10 },
{ 1102820088, 1, 10 },
{ 1089704289, 1, 10 },
{ 1085401409, 1, 10 },
{ 1079010430, 0, 10 },
{ 1076896795, 1, 10 },
{ 1066451627, 1, 10 },
{ 1064386861, 1, 10 },
{ 1058240258, 0, 10 },
{ 1048152171, 1, 10 },
{ 1046157591, 0, 10 },
{ 1036297481, 1, 10 },
{ 1034347721, 1, 10 },
{ 1028542215, 0, 10 },
{ 1011510237, 1, 10 },
{ 1007801675, 1, 10 },
{ 1005957573, 1, 10 },
{ 1002289542, 1, 10 },
{ 996837378, 0, 10 },
{ 991444209, 0, 10 },
{ 984343445, 0, 10 },
{ 979084263, 1, 10 },
{ 973880981, 1, 10 },
{ 955266401, 1, 10 },
{ 953609391, 0, 10 },
{ 945409826, 1, 10 },
{ 938951006, 0, 10 },
{ 931000532, 0, 10 },
{ 926294547, 1, 10 },
{ 921635899, 1, 10 },
{ 915496776, 0, 10 },
{ 906439924, 0, 10 },
{ 903460664, 0, 10 },
{ 899028314, 0, 10 },
{ 894639241, 1, 10 },
{ 893185725, 1, 10 },
{ 888853377, 1, 10 },
{ 880313553, 1, 10 },
{ 873321388, 1, 10 },
{ 861011455, 0, 10 },
{ 859665073, 0, 10 },
{ 856984901, 0, 10 },
{ 852995832, 1, 10 },
{ 851674382, 1, 10 },
{ 847734486, 0, 10 },
{ 845128077, 0, 10 },
{ 843830873, 1, 10 },
{ 841248376, 1, 10 },
{ 833594866, 0, 10 },
{ 832332799, 1, 10 },
{ 828569426, 0, 10 },
{ 807870410, 0, 10 },
{ 804324527, 0, 10 },
{ 800809634, 1, 10 },
{ 796170621, 1, 10 },
{ 785926825, 0, 10 },
{ 780348920, 0, 10 },
{ 772671559, 0, 10 },
{ 770505696, 0, 10 },
{ 769427311, 1, 10 },
{ 767279573, 0, 10 },
{ 764080353, 0, 10 },
{ 759855997, 1, 10 },
{ 757761287, 1, 11 },
{ 756718257, 1, 11 },
{ 753606325, 0, 11 },
{ 747458618, 1, 11 },
{ 742411633, 0, 11 },
{ 741410403, 1, 11 },
{ 739416024, 1, 11 },
{ 738422853, 0, 11 },
{ 736444493, 0, 11 },
{ 733496750, 0, 11 },
{ 727671494, 1, 11 },
{ 721938035, 1, 11 },
{ 718165662, 0, 11 },
{ 712580446, 0, 11 },
{ 709820289, 1, 11 },
{ 707992033, 1, 11 },
{ 705267240, 1, 11 },
{ 701666642, 0, 11 },
{ 699880094, 1, 11 },
{ 696334153, 1, 11 },
{ 694574623, 0, 11 },
{ 688485678, 1, 11 },
{ 686765539, 0, 11 },
{ 684201386, 1, 11 },
{ 683350918, 1, 11 },
{ 681656310, 0, 11 },
{ 679130097, 1, 11 },
{ 678292182, 1, 11 },
{ 675790798, 0, 11 },
{ 671662570, 1, 11 },
{ 663555599, 1, 11 },
{ 661161532, 1, 11 },
{ 659575062, 0, 11 },
{ 658784678, 1, 11 },
{ 649445734, 1, 11 },
{ 647914925, 1, 11 },
{ 647152224, 0, 11 },
{ 643365493, 1, 11 },
{ 638879505, 0, 11 },
{ 638137915, 1, 11 },
{ 634455642, 1, 11 },
{ 631540280, 1, 11 },
{ 629371281, 0, 11 },
{ 627217129, 1, 11 },
{ 625077674, 0, 11 },
{ 618745992, 0, 11 },
{ 616663841, 0, 11 },
{ 615283507, 1, 11 },
{ 614595656, 0, 11 },
{ 610500626, 1, 11 },
{ 607129557, 1, 11 },
{ 603133093, 0, 11 },
{ 600497885, 1, 11 },
{ 595295954, 1, 11 },
{ 590817640, 0, 11 },
{ 588918922, 1, 11 },
{ 587659876, 0, 11 },
{ 587032369, 1, 11 },
{ 585781368, 1, 11 },
{ 585157865, 0, 11 },
{ 582060152, 1, 11 },
{ 578385917, 0, 11 },
{ 576566139, 1, 11 },
{ 574757777, 1, 11 },
{ 569400118, 0, 11 },
{ 568810982, 0, 11 },
{ 564141420, 1, 11 },
{ 563563110, 1, 11 },
{ 557279081, 1, 11 },
{ 555589504, 0, 11 },
{ 553352606, 0, 11 },
{ 551686717, 1, 11 },
{ 550581686, 1, 11 },
{ 550030829, 1, 11 },
{ 548932415, 1, 11 },
{ 546748696, 1, 11 },
{ 545122275, 0, 11 },
{ 542432969, 0, 11 },
{ 541898289, 0, 11 },
{ 539240622, 0, 11 },
{ 535563384, 1, 11 },
{ 532967343, 0, 11 },
{ 531421763, 1, 11 },
{ 528357342, 0, 11 },
{ 527850037, 1, 11 },
{ 526838346, 0, 11 },
{ 526333953, 0, 11 },
{ 523826407, 0, 11 },
{ 520848710, 1, 11 },
{ 520355716, 0, 11 },
{ 516445105, 0, 11 },
{ 515960407, 1, 11 },
{ 514511758, 1, 11 },
{ 513550503, 1, 11 },
{ 513071222, 0, 11 },
{ 510688169, 0, 11 },
{ 508797607, 0, 11 },
{ 504594597, 1, 11 },
{ 499097425, 1, 11 },
{ 498192854, 0, 11 },
{ 496842127, 1, 11 },
{ 495052511, 1, 11 },
{ 491511680, 0, 11 },
{ 491072634, 1, 11 },
{ 490196892, 0, 11 },
{ 488454744, 0, 11 },
{ 485007335, 0, 11 },
{ 484579827, 1, 11 },
{ 483727069, 0, 11 },
{ 482030525, 1, 11 },
{ 480765906, 1, 11 },
{ 479507906, 0, 11 },
{ 478672890, 0, 11 },
{ 476185200, 1, 11 },
{ 475773097, 1, 11 },
{ 471286596, 0, 11 },
{ 470077652, 0, 11 },
{ 469676048, 0, 11 },
{ 468475342, 1, 11 },
{ 467678276, 1, 11 },
{ 466487750, 1, 11 },
{ 463733289, 0, 11 },
{ 462562738, 0, 11 },
{ 461785648, 0, 11 },
{ 461398081, 1, 11 },
{ 460239275, 0, 11 },
{ 459469966, 0, 11 },
{ 458320812, 0, 11 },
{ 456039663, 1, 11 },
{ 454907583, 0, 11 },
{ 453781109, 1, 11 },
{ 451174242, 1, 11 },
{ 450434915, 1, 11 },
{ 449330457, 0, 11 },
{ 447137710, 0, 11 },
{ 445687729, 1, 11 },
{ 444606400, 1, 11 },
{ 443888425, 0, 11 },
{ 439277518, 1, 11 },
{ 436141066, 1, 11 },
{ 434417870, 0, 11 },
{ 433049085, 1, 11 },
{ 432367923, 0, 11 },
{ 431350187, 1, 11 },
{ 431012006, 1, 11 },
{ 430000637, 0, 11 },
{ 426332543, 0, 11 },
{ 424358019, 1, 11 },
{ 424030709, 0, 11 },
{ 421430290, 1, 11 },
{ 420142005, 1, 11 },
{ 419500812, 0, 11 },
{ 417588921, 0, 11 },
{ 415380290, 1, 11 },
{ 413816947, 0, 11 },
{ 413505689, 1, 11 },
{ 412884577, 0, 11 },
{ 411647933, 0, 11 },
{ 410725300, 0, 11 },
{ 409806794, 0, 11 },
{ 409196735, 1, 11 },
{ 408892387, 0, 11 },
{ 408285046, 0, 11 },
{ 407377409, 1, 11 },
{ 406173486, 1, 11 },
{ 405574190, 0, 11 },
{ 405275204, 0, 11 },
{ 404380886, 0, 11 },
{ 402899094, 1, 11 },
{ 402604038, 0, 11 },
{ 401135216, 1, 11 },
{ 399967853, 0, 11 },
{ 399386716, 0, 11 },
{ 397365966, 0, 11 },
{ 395935048, 0, 11 },
{ 394231491, 0, 11 },
{ 393948989, 0, 11 },
{ 393103907, 0, 11 },
{ 392542530, 1, 11 },
{ 392262443, 1, 11 },
{ 390036051, 1, 11 },
{ 388108587, 1, 11 },
{ 387561377, 1, 11 },
{ 386743450, 0, 11 },
{ 385658235, 0, 11 },
{ 384848312, 1, 11 },
{ 384310251, 0, 11 },
{ 381907478, 0, 11 },
{ 380849196, 0, 11 },
{ 379534563, 0, 12 },
{ 378750130, 1, 12 },
{ 377968934, 0, 12 },
{ 376932337, 1, 12 },
{ 375644560, 1, 12 },
{ 374110795, 1, 12 },
{ 372337158, 1, 12 },
{ 371833489, 1, 12 },
{ 371080536, 0, 12 },
{ 370330626, 0, 12 },
{ 370081329, 0, 12 },
{ 366626085, 0, 12 },
{ 366381749, 0, 12 },
{ 365164938, 0, 12 },
{ 364197293, 1, 12 },
{ 363715391, 1, 12 },
{ 362038732, 0, 12 },
{ 361562521, 1, 12 },
{ 360613850, 0, 12 },
{ 359200140, 0, 12 },
{ 358497433, 1, 12 },
{ 357100236, 1, 12 },
{ 356636921, 1, 12 },
{ 355944198, 1, 12 },
{ 353654432, 0, 12 },
{ 352520560, 1, 12 },
{ 352294658, 1, 12 },
{ 350497809, 1, 12 },
{ 347616702, 0, 12 },
{ 347177653, 1, 12 },
{ 346958545, 0, 12 },
{ 345649679, 0, 12 },
{ 344998942, 0, 12 },
{ 344566477, 0, 12 },
{ 343275563, 0, 12 },
{ 342633726, 1, 12 },
{ 341781669, 0, 12 },
{ 341357227, 0, 12 },
{ 340511498, 1, 12 },
{ 338207206, 1, 12 },
{ 337999271, 0, 12 },
{ 337584166, 0, 12 },
{ 337376995, 1, 12 },
{ 336139293, 1, 12 },
{ 333286338, 0, 12 },
{ 333084407, 1, 12 },
{ 332480081, 0, 12 },
{ 331877944, 0, 12 },
{ 331277984, 0, 12 },
{ 330879214, 0, 12 },
{ 330282856, 1, 12 },
{ 330084548, 0, 12 },
{ 328899679, 1, 12 },
{ 328506611, 1, 12 },
{ 327333024, 1, 12 },
{ 327138241, 0, 12 },
{ 326167792, 1, 12 },
{ 325974393, 1, 12 },
{ 324435417, 0, 12 },
{ 324244066, 0, 12 },
{ 322721347, 0, 12 },
{ 322154008, 0, 12 },
{ 320277200, 1, 12 },
{ 318791426, 0, 12 },
{ 318053696, 1, 12 },
{ 317686110, 1, 12 },
{ 317502636, 0, 12 },
{ 317136322, 0, 12 },
{ 316953482, 0, 12 },
{ 314956066, 1, 12 },
{ 314235961, 1, 12 },
{ 313161956, 1, 12 },
{ 312627702, 0, 12 },
{ 311741318, 0, 12 },
{ 311564644, 0, 12 },
{ 311211896, 0, 12 },
{ 310684269, 0, 12 },
{ 310508791, 0, 12 },
{ 309983543, 1, 12 },
{ 309112069, 0, 12 },
{ 308938361, 1, 12 },
{ 307900204, 0, 12 },
{ 307040388, 0, 12 },
{ 306869000, 1, 12 },
{ 306014926, 0, 12 },
{ 304827177, 1, 12 },
{ 304320960, 0, 12 },
{ 303984415, 0, 12 },
{ 303480990, 1, 12 },
{ 302812346, 0, 12 },
{ 302312793, 0, 12 },
{ 301814885, 1, 12 },
{ 300495116, 0, 12 },
{ 299512838, 0, 12 },
{ 299349749, 0, 12 },
{ 299024103, 1, 12 },
{ 297889902, 0, 12 },
{ 297406445, 1, 12 },
{ 297085012, 0, 12 },
{ 296444224, 1, 12 },
{ 295647117, 0, 12 },
{ 295012511, 0, 12 },
{ 294538341, 1, 12 },
{ 294065693, 1, 12 },
{ 292345554, 0, 12 },
{ 291879912, 0, 12 },
{ 291725027, 1, 12 },
{ 290953064, 0, 12 },
{ 289879153, 1, 12 },
{ 289573776, 1, 12 },
{ 289116915, 1, 12 },
{ 287754941, 0, 12 },
{ 287604402, 0, 12 },
{ 286854064, 1, 12 },
{ 285810145, 0, 12 },
{ 285513276, 1, 12 },
{ 285365073, 1, 12 },
{ 284626360, 0, 12 },
{ 283598563, 0, 12 },
{ 283306268, 1, 12 },
{ 282723484, 0, 12 },
{ 281420944, 0, 12 },
{ 281133119, 0, 12 },
{ 280702483, 1, 12 },
{ 280559231, 1, 12 },
{ 280273165, 1, 12 },
{ 279845159, 0, 12 },
{ 279702780, 0, 12 },
{ 278851541, 1, 12 },
{ 278568945, 1, 12 },
{ 277164514, 1, 12 },
{ 275635906, 0, 12 },
{ 274809205, 0, 12 },
{ 274671903, 1, 12 },
{ 274397711, 0, 12 },
{ 273987448, 0, 12 },
{ 273578409, 1, 12 },
{ 273442335, 0, 12 },
{ 273034921, 1, 12 },
{ 271551402, 1, 12 },
{ 271417336, 0, 12 },
{ 271015930, 0, 12 },
{ 269951296, 0, 12 },
{ 269554211, 1, 12 },
{ 268763536, 1, 12 },
{ 268632208, 1, 12 },
{ 268238992, 0, 12 },
{ 267456003, 0, 12 },
{ 266419101, 0, 12 },
{ 266290053, 0, 12 },
{ 266032332, 0, 12 },
{ 265646685, 0, 12 },
{ 264751175, 0, 12 },
{ 264496422, 1, 12 },
{ 264369230, 1, 12 },
{ 263229980, 1, 12 },
{ 261726167, 1, 12 },
{ 261104637, 1, 12 },
{ 260733134, 1, 12 },
{ 260609535, 0, 12 },
{ 259993291, 1, 12 },
{ 259870392, 0, 12 },
{ 259257634, 1, 12 },
{ 259135430, 0, 12 },
{ 258526129, 1, 12 },
{ 258161922, 1, 12 },
{ 258040748, 1, 12 },
{ 257436579, 0, 12 },
{ 257316084, 1, 12 },
{ 256715300, 0, 12 },
{ 256356173, 1, 12 },
{ 255878899, 0, 12 },
{ 254104837, 0, 12 },
{ 253518937, 0, 12 },
{ 253402081, 0, 12 },
{ 252819413, 1, 12 },
{ 252355205, 0, 12 },
{ 252008166, 0, 12 },
{ 251431884, 0, 12 },
{ 250401191, 0, 12 },
{ 250059501, 1, 12 },
{ 249378913, 1, 12 },
{ 248702019, 1, 12 },
{ 248589561, 0, 12 },
{ 247581992, 1, 12 },
{ 247247949, 0, 12 },
{ 247025753, 1, 12 },
{ 246693208, 0, 12 },
{ 246361557, 0, 12 },
{ 245371932, 1, 12 },
{ 245262464, 1, 12 },
{ 244716588, 0, 12 },
{ 243956430, 0, 12 },
{ 243632091, 1, 12 },
{ 243416344, 1, 12 },
{ 243308614, 1, 12 },
{ 243093440, 0, 12 },
{ 241810343, 0, 12 },
{ 241704029, 0, 12 },
{ 241068105, 1, 12 },
{ 240751396, 1, 12 },
{ 239910894, 1, 12 },
{ 239492840, 0, 12 },
{ 239180254, 1, 12 },
{ 238868483, 1, 12 },
{ 237938028, 1, 12 },
{ 237117021, 1, 12 },
{ 237014794, 0, 12 },
{ 236810603, 0, 12 },
{ 236504975, 0, 12 },
{ 236403274, 1, 12 },
{ 236098696, 1, 12 },
{ 235794902, 0, 12 },
{ 235290312, 0, 12 },
{ 234988593, 1, 12 },
{ 234387471, 1, 12 },
{ 233789417, 0, 12 },
{ 232898036, 0, 12 },
{ 232799413, 1, 12 },
{ 232504045, 0, 12 },
{ 232307549, 0, 12 },
{ 231427411, 0, 12 },
{ 231038375, 1, 12 },
{ 229879078, 0, 12 },
{ 229686991, 1, 12 },
{ 229591069, 0, 12 },
{ 229399463, 1, 12 },
{ 229112654, 1, 12 },
{ 229017211, 0, 12 },
{ 228446214, 0, 12 },
{ 228256514, 0, 12 },
{ 227595038, 0, 12 },
{ 226190419, 1, 12 },
{ 225726058, 0, 12 },
{ 225448355, 1, 12 },
{ 224894994, 1, 12 },
{ 224252830, 1, 12 },
{ 223978739, 0, 12 },
{ 223523405, 0, 12 },
{ 222979442, 0, 12 },
{ 222889039, 0, 12 },
{ 222708452, 1, 12 },
{ 222438120, 1, 12 },
{ 222078697, 0, 12 },
{ 221809891, 0, 12 },
{ 221363323, 1, 12 },
{ 221274226, 0, 12 },
{ 221096245, 1, 12 },
{ 220475562, 1, 12 },
{ 220210620, 1, 12 },
{ 219946315, 0, 12 },
{ 219770463, 1, 12 },
{ 219507213, 0, 12 },
{ 219419602, 1, 12 },
{ 218982599, 0, 12 },
{ 218895407, 0, 12 },
{ 218200363, 0, 12 },
{ 217681969, 1, 12 },
{ 217337740, 1, 12 },
{ 216567191, 0, 12 },
{ 216396699, 1, 12 },
{ 216141464, 1, 12 },
{ 215632796, 1, 12 },
{ 215548251, 0, 12 },
{ 215295012, 1, 12 },
{ 215042368, 1, 12 },
{ 214790316, 1, 12 },
{ 213621843, 1, 12 },
{ 213373108, 1, 12 },
{ 212794973, 1, 12 },
{ 212630367, 1, 12 },
{ 212301917, 0, 12 },
{ 211892779, 0, 12 },
{ 211566601, 1, 12 },
{ 211079214, 1, 12 },
{ 210352330, 0, 12 },
{ 210191479, 1, 12 },
{ 210111146, 1, 12 },
{ 209950664, 1, 12 },
{ 208992896, 1, 12 },
{ 208517282, 0, 12 },
{ 208280286, 0, 12 },
{ 208201407, 0, 12 },
{ 207572518, 0, 12 },
{ 207337663, 1, 12 },
{ 207103339, 1, 12 },
{ 206558638, 0, 12 },
{ 206171316, 0, 12 },
{ 205631499, 1, 12 },
{ 205477785, 1, 12 },
{ 204332211, 1, 12 },
{ 204104627, 1, 12 },
{ 203877550, 1, 12 },
{ 203650978, 0, 12 },
{ 203349663, 0, 12 },
{ 203124262, 0, 12 },
{ 202974271, 1, 12 },
{ 202899359, 1, 12 },
{ 202451045, 1, 12 },
{ 202227631, 0, 12 },
{ 202078961, 1, 12 },
{ 202004708, 1, 12 },
{ 201782277, 1, 12 },
{ 200970870, 0, 12 },
{ 200750708, 1, 12 },
{ 200677428, 0, 12 },
{ 200531028, 1, 12 },
{ 199874864, 1, 12 },
{ 199802222, 1, 12 },
{ 199657096, 1, 12 },
{ 199222980, 1, 12 },
{ 199150811, 1, 12 },
{ 198934617, 0, 12 },
{ 198790748, 1, 12 },
{ 197860649, 1, 12 },
{ 197647246, 0, 12 },
{ 197434302, 0, 12 },
{ 197292594, 1, 12 },
{ 197009788, 1, 12 },
{ 196657419, 0, 12 },
{ 195538259, 0, 12 },
{ 194983442, 0, 12 },
{ 194914311, 0, 12 },
{ 194707212, 1, 12 },
{ 194569391, 0, 12 },
{ 194500553, 1, 12 },
{ 194363024, 1, 12 },
{ 194294333, 0, 12 },
{ 193951601, 1, 12 },
{ 193473804, 0, 12 },
{ 193269754, 0, 12 },
{ 193133959, 0, 12 },
{ 192862941, 1, 12 },
{ 192525237, 0, 12 },
{ 192323181, 1, 12 },
{ 191652715, 1, 12 },
{ 191519183, 0, 12 },
{ 191452486, 1, 12 },
{ 191252675, 0, 12 },
{ 190259842, 1, 12 },
{ 190128243, 0, 12 },
{ 189865589, 1, 12 },
{ 189538291, 1, 13 },
{ 189342454, 0, 13 },
{ 189147020, 1, 13 },
{ 188887069, 0, 13 },
{ 188692574, 0, 13 },
{ 188304783, 0, 13 },
{ 188175873, 1, 13 },
{ 187982839, 1, 13 },
{ 187918583, 0, 13 },
{ 187726076, 1, 13 },
{ 187597957, 1, 13 },
{ 187406107, 0, 13 },
{ 187342244, 0, 13 },
{ 187023580, 1, 13 },
{ 186959978, 0, 13 },
{ 186452709, 1, 13 },
{ 186263193, 0, 13 },
{ 185634244, 1, 13 },
{ 185508964, 0, 13 },
{ 185134135, 1, 13 },
{ 184698745, 0, 13 },
{ 183834079, 1, 13 },
{ 183649846, 0, 13 },
{ 183038393, 1, 13 },
{ 182916591, 0, 13 },
{ 182370481, 0, 13 },
{ 182128810, 1, 13 },
{ 181947977, 1, 13 },
{ 181827622, 0, 13 },
{ 181647386, 1, 13 },
{ 181228223, 0, 13 },
{ 181049173, 1, 13 },
{ 180870477, 0, 13 },
{ 180573432, 1, 13 },
{ 180514140, 1, 13 },
{ 180218264, 0, 13 },
{ 179864490, 1, 13 },
{ 179629411, 1, 13 },
{ 179336426, 0, 13 },
{ 179277944, 0, 13 },
{ 178986103, 0, 13 },
{ 178753313, 0, 13 },
{ 178405262, 0, 13 },
{ 178116253, 0, 13 },
{ 177426437, 0, 13 },
{ 177369193, 1, 13 },
{ 177254817, 0, 13 },
{ 177026506, 0, 13 },
{ 176855658, 1, 13 },
{ 176741943, 1, 13 },
{ 176514951, 0, 13 },
{ 176006343, 1, 13 },
{ 175725048, 1, 13 },
{ 175556703, 0, 13 },
{ 175388679, 0, 13 },
{ 175332742, 1, 13 },
{ 175165147, 1, 13 },
{ 174886532, 1, 13 },
{ 174553362, 1, 13 },
{ 174497957, 1, 13 },
{ 174221459, 1, 13 },
{ 174055980, 1, 13 },
{ 173890816, 0, 13 },
{ 173725964, 1, 13 },
{ 173506648, 0, 13 },
{ 173342524, 0, 13 },
{ 173069672, 1, 13 },
{ 172906373, 1, 13 },
{ 172852009, 0, 13 },
{ 172689120, 1, 13 },
{ 172526538, 1, 13 },
{ 172364262, 1, 13 },
{ 172094479, 1, 13 },
{ 171879260, 1, 13 },
{ 171236821, 1, 13 },
{ 171076961, 0, 13 },
{ 170493352, 1, 13 },
{ 170440494, 1, 13 },
{ 169966243, 1, 13 },
{ 169861212, 1, 13 },
{ 169651540, 0, 13 },
{ 169390175, 1, 13 },
{ 168610892, 1, 13 },
{ 168404293, 0, 13 },
{ 167941290, 1, 13 },
{ 167838746, 1, 13 },
{ 167787521, 1, 13 },
{ 167531865, 0, 13 },
{ 167378844, 1, 13 },
{ 167327900, 0, 13 },
{ 167175251, 1, 13 },
{ 167073640, 1, 13 },
{ 166617916, 1, 13 },
{ 166416169, 0, 13 },
{ 166114463, 0, 13 },
{ 165663949, 0, 13 },
{ 165265539, 0, 13 },
{ 165116628, 1, 13 },
{ 165067051, 1, 13 },
{ 164770212, 1, 13 },
{ 164622193, 1, 13 },
{ 164376084, 1, 13 },
{ 164326951, 0, 13 },
{ 164081723, 1, 13 },
{ 164032766, 0, 13 },
{ 163886068, 0, 13 },
{ 163642153, 1, 13 },
{ 163301890, 1, 13 },
{ 163204932, 1, 13 },
{ 162625592, 1, 13 },
{ 162577499, 1, 13 },
{ 162193779, 0, 13 },
{ 162145941, 1, 13 },
{ 161907175, 1, 13 },
{ 161859507, 0, 13 },
{ 161621583, 0, 13 },
{ 161147828, 0, 13 },
{ 161053410, 0, 13 },
{ 161006242, 1, 13 },
{ 160911990, 1, 13 },
{ 160723816, 1, 13 },
{ 160348786, 1, 13 },
{ 160208601, 0, 13 },
{ 160068660, 1, 13 },
{ 160022068, 0, 13 },
{ 159743081, 1, 13 },
{ 159372609, 0, 13 },
{ 159188016, 1, 13 },
{ 159095880, 1, 13 },
{ 158957876, 0, 13 },
{ 158271431, 0, 13 },
{ 158225878, 1, 13 },
{ 157998510, 0, 13 },
{ 157953114, 1, 13 },
{ 157817085, 0, 13 },
{ 157726528, 1, 13 },
{ 157590888, 1, 13 },
{ 157455482, 0, 13 },
{ 157275301, 0, 13 },
{ 157140436, 0, 13 },
{ 157050654, 0, 13 },
{ 156781923, 1, 13 },
{ 156647903, 0, 13 },
{ 156469564, 1, 13 },
{ 156202817, 0, 13 },
{ 156114103, 1, 13 },
{ 155804397, 0, 13 },
{ 155539911, 0, 13 },
{ 155320190, 1, 13 },
{ 154795386, 1, 13 },
{ 154664739, 0, 13 },
{ 154404104, 1, 13 },
{ 154274116, 1, 13 },
{ 154230836, 0, 13 },
{ 153756346, 0, 13 },
{ 153584527, 0, 13 },
{ 153199335, 1, 13 },
{ 152986173, 1, 13 },
{ 152858561, 0, 13 },
{ 152561625, 0, 13 },
{ 152476997, 1, 13 },
{ 152434719, 0, 13 },
{ 152308024, 1, 13 },
{ 152097334, 1, 13 },
{ 151929201, 1, 13 },
{ 151803345, 0, 13 },
{ 151719557, 0, 13 },
{ 151594048, 0, 13 },
{ 150969604, 1, 13 },
{ 150679954, 1, 13 },
{ 150473741, 1, 13 },
{ 150432566, 1, 13 },
{ 150185989, 1, 13 },
{ 149981125, 1, 13 },
{ 149940219, 1, 13 },
{ 149613774, 1, 13 },
{ 149573069, 0, 13 },
{ 149207712, 0, 13 },
{ 148723337, 0, 13 },
{ 148362114, 1, 13 },
{ 148242096, 1, 13 },
{ 147922996, 0, 13 },
{ 147565646, 0, 13 },
{ 147446913, 0, 13 },
{ 147407377, 1, 13 },
{ 147052511, 1, 13 },
{ 146973884, 1, 13 },
{ 146856101, 0, 13 },
{ 146816882, 0, 13 },
{ 146621100, 0, 13 },
{ 146464850, 0, 13 },
{ 146270005, 1, 13 },
{ 146153347, 0, 13 },
{ 146036874, 1, 13 },
{ 145881866, 1, 13 },
{ 145804486, 0, 13 },
{ 145688569, 0, 13 },
{ 145649971, 0, 13 },
{ 145457286, 1, 13 },
{ 145418811, 0, 13 },
{ 145188383, 1, 13 },
{ 145111737, 0, 13 },
{ 144996918, 0, 13 },
{ 144882281, 0, 13 },
{ 144844109, 0, 13 },
{ 144615498, 0, 13 },
{ 144539454, 1, 13 },
{ 144273931, 0, 13 },
{ 143933974, 1, 13 },
{ 143858646, 0, 13 },
{ 143745800, 1, 13 },
{ 143370926, 0, 13 },
{ 143296185, 1, 13 },
{ 143146938, 0, 13 },
{ 143035206, 0, 13 },
{ 142960815, 0, 13 },
{ 142812265, 0, 13 },
{ 142738106, 0, 13 },
{ 142479154, 0, 13 },
{ 142368461, 1, 13 },
{ 142294762, 1, 13 },
{ 142037415, 0, 13 },
{ 141817571, 0, 13 },
{ 141744441, 0, 13 },
{ 141707904, 1, 13 },
{ 141162104, 0, 13 },
{ 141089648, 1, 13 },
{ 140656470, 1, 13 },
{ 140548591, 1, 13 },
{ 140440877, 1, 13 },
{ 140225944, 1, 13 },
{ 140011668, 0, 13 },
{ 139762505, 1, 13 },
{ 139655992, 1, 13 },
{ 139585074, 0, 13 },
{ 139549642, 0, 13 },
{ 139478831, 1, 13 },
{ 139161072, 0, 13 },
{ 139055473, 1, 13 },
{ 138844757, 0, 13 }};






uint8 small_sqrt_tab[54][256] = { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 3, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 5, 2, 4, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 4, 2, 0, 0, 0, 0, 3, 6, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 6, 0, 2, 0, 0, 0, 5, 3, 0, 0, 0, 8, 0, 7, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 9, 5, 8, 0, 3, 0, 7, 0, 0, 0, 0, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 5, 7, 2, 0, 11, 0, 10, 3, 0, 0, 9, 6, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 11, 8, 6, 0, 3, 0, 0, 0, 10, 0, 0, 4, 0, 0, 0, 7, 0, 14, 9, 13, 5, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 8, 0, 2, 6, 0, 10, 15, 3, 14, 0, 0, 0, 13, 0, 4, 0, 7, 9, 12, 0, 0, 0, 0, 5, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 15, 2, 0, 0, 9, 0, 3, 11, 14, 7, 0, 0, 0, 4, 0, 0, 0, 0, 13, 0, 0, 0, 5, 10, 8, 18, 0, 17, 0, 0, 12, 16, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 17, 0, 2, 13, 0, 0, 7, 3, 16, 0, 0, 0, 0, 0, 4, 0, 10, 0, 15, 12, 0, 8, 0, 5, 0, 0, 0, 0, 0, 20, 14, 19, 0, 0, 6, 18, 0, 11, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 7, 0, 0, 3, 15, 21, 0, 20, 10, 12, 4, 19, 0, 0, 0, 8, 0, 18, 14, 5, 0, 0, 0, 0, 0, 17, 0, 0, 0, 11, 6, 0, 9, 0, 13, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 7, 12, 2, 0, 10, 17, 14, 3, 0, 0, 23, 0, 22, 0, 4, 8, 21, 0, 0, 16, 0, 0, 20, 5, 0, 11, 13, 0, 0, 0, 19, 0, 9, 0, 6, 15, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 18, 22, 0, 3, 13, 8, 0, 15, 0, 11, 4, 21, 0, 0, 0, 0, 0, 0, 17, 5, 0, 0, 9, 20, 0, 0, 0, 0, 0, 0, 6, 14, 12, 0, 26, 0, 25, 19, 16, 0, 24, 10, 0, 7, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 11, 2, 8, 0, 19, 0, 3, 0, 0, 22, 0, 0, 29, 4, 28, 0, 14, 16, 27, 9, 0, 0, 5, 12, 26, 21, 18, 0, 0, 0, 0, 0, 25, 6, 0, 0, 0, 0, 10, 0, 0, 0, 24, 20, 0, 15, 7, 0, 13, 0, 17, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 8, 2, 26, 0, 0, 0, 3, 0, 0, 16, 14, 21, 25, 4, 0, 0, 18, 9, 0, 12, 0, 0, 5, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 6, 0, 0, 10, 0, 23, 15, 0, 0, 17, 30, 13, 29, 7, 0, 0, 28, 0, 0, 0, 19, 22, 27, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 26, 0, 0, 3, 12, 0, 0, 0, 9, 22, 4, 33, 0, 32, 0, 17, 25, 31, 15, 5, 19, 0, 0, 30, 0, 0, 0, 10, 0, 13, 6, 29, 0, 21, 24, 0, 0, 0, 0, 0, 0, 28, 0, 7, 0, 0, 0, 0, 11, 16, 18, 0, 0, 27, 23, 0, 14, 0, 8, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 12, 28, 2, 17, 19, 0, 24, 3, 9, 0, 15, 0, 0, 21, 4, 0, 35, 27, 34, 0, 0, 0, 33, 5, 0, 13, 0, 10, 32, 0, 23, 0, 0, 0, 6, 26, 31, 0, 18, 0, 0, 16, 0, 20, 0, 0, 30, 7, 11, 0, 0, 0, 14, 0, 0, 25, 22, 0, 29, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 32, 21, 2, 0, 15, 0, 9, 3, 0, 0, 31, 0, 0, 0, 4, 0, 23, 26, 0, 0, 0, 13, 30, 5, 0, 10, 0, 0, 0, 0, 18, 0, 0, 20, 6, 16, 29, 0, 0, 25, 0, 0, 0, 0, 22, 0, 11, 7, 14, 0, 0, 0, 28, 36, 0, 35, 0, 0, 0, 34, 0, 0, 8, 24, 0, 33, 0, 19, 17, 12, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 9, 0, 2, 20, 0, 0, 18, 3, 22, 13, 0, 31, 0, 0, 4, 0, 27, 16, 39, 10, 38, 24, 0, 5, 37, 0, 0, 0, 0, 30, 36, 0, 0, 0, 6, 0, 14, 0, 35, 0, 11, 0, 26, 19, 21, 0, 0, 7, 34, 29, 17, 0, 0, 23, 0, 0, 0, 0, 0, 0, 33, 0, 8, 12, 0, 15, 0, 0, 0, 0, 25, 28, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 13, 2, 0, 0, 16, 0, 3, 33, 29, 26, 0, 0, 0, 4, 10, 0, 0, 0, 41, 0, 40, 0, 5, 21, 39, 32, 19, 14, 23, 0, 38, 0, 0, 6, 28, 11, 0, 17, 37, 0, 0, 25, 0, 0, 0, 31, 7, 0, 36, 0, 0, 0, 0, 0, 0, 0, 15, 0, 12, 0, 35, 8, 27, 0, 0, 20, 22, 30, 0, 0, 0, 0, 18, 0, 34, 24, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 25, 0, 2, 19, 0, 0, 39, 3, 30, 10, 0, 0, 0, 0, 4, 27, 14, 0, 38, 33, 17, 0, 0, 5, 0, 0, 0, 0, 0, 0, 11, 0, 37, 0, 6, 0, 0, 22, 29, 0, 24, 0, 20, 32, 0, 15, 0, 7, 36, 0, 0, 26, 0, 12, 0, 18, 0, 0, 0, 0, 0, 0, 8, 0, 0, 44, 35, 43, 0, 31, 28, 42, 0, 0, 0, 0, 16, 41, 13, 9, 0, 0, 23, 21, 0, 40, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 14, 10, 2, 0, 43, 0, 28, 3, 0, 37, 20, 0, 0, 0, 4, 0, 42, 0, 0, 0, 33, 0, 11, 5, 0, 30, 0, 0, 0, 15, 41, 18, 0, 36, 6, 0, 0, 0, 0, 0, 0, 25, 23, 0, 0, 12, 40, 7, 27, 0, 0, 21, 32, 0, 0, 0, 0, 0, 0, 35, 16, 0, 8, 29, 39, 0, 0, 0, 19, 0, 13, 48, 0, 47, 0, 0, 0, 46, 0, 9, 0, 0, 0, 45, 38, 0, 31, 34, 0, 24, 0, 44, 26, 17, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 45, 39, 0, 0, 3, 0, 0, 0, 35, 32, 0, 4, 44, 0, 25, 11, 18, 27, 15, 23, 5, 0, 0, 0, 0, 38, 43, 0, 29, 0, 0, 6, 21, 0, 0, 0, 0, 0, 12, 0, 34, 0, 42, 0, 7, 0, 0, 31, 0, 16, 0, 37, 0, 19, 0, 0, 0, 0, 0, 8, 41, 0, 0, 13, 0, 26, 24, 0, 0, 0, 0, 50, 28, 49, 33, 22, 9, 48, 0, 36, 40, 0, 17, 47, 0, 0, 0, 30, 0, 0, 14, 46, 20, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 38, 0, 2, 0, 0, 25, 27, 3, 0, 0, 0, 42, 23, 18, 4, 29, 11, 15, 0, 0, 0, 34, 0, 5, 51, 0, 50, 21, 37, 0, 49, 41, 31, 0, 6, 0, 48, 0, 0, 12, 0, 0, 0, 0, 47, 0, 0, 7, 16, 0, 19, 0, 0, 40, 46, 0, 26, 33, 36, 24, 0, 28, 8, 0, 13, 0, 45, 0, 0, 0, 22, 0, 0, 0, 30, 0, 0, 39, 0, 9, 44, 17, 0, 0, 0, 0, 0, 0, 0, 20, 35, 14, 0, 0, 0, 32, 43, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 18, 2, 0, 0, 0, 0, 3, 44, 15, 36, 21, 11, 0, 4, 0, 0, 33, 0, 0, 0, 39, 0, 5, 0, 53, 0, 52, 43, 0, 0, 51, 26, 28, 6, 12, 0, 50, 19, 24, 16, 0, 30, 0, 0, 49, 35, 7, 0, 0, 42, 38, 0, 0, 22, 48, 0, 0, 0, 32, 13, 0, 8, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 17, 41, 0, 0, 20, 0, 9, 0, 46, 0, 37, 34, 27, 0, 14, 25, 0, 29, 0, 0, 0, 0, 0, 0, 45, 10, 23, 40, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 49, 2, 21, 0, 15, 0, 3, 0, 0, 11, 0, 0, 48, 4, 0, 0, 0, 42, 28, 26, 0, 0, 5, 35, 38, 30, 47, 0, 24, 0, 0, 19, 12, 6, 0, 16, 0, 0, 0, 0, 32, 0, 46, 41, 0, 22, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 37, 0, 45, 8, 0, 34, 0, 0, 0, 0, 17, 0, 20, 40, 27, 0, 0, 29, 0, 25, 9, 54, 44, 53, 0, 0, 14, 52, 31, 0, 0, 0, 23, 51, 0, 0, 36, 0, 0, 10, 0, 50, 0, 39, 43, 18, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 51, 0, 2, 0, 0, 32, 11, 3, 0, 24, 0, 37, 50, 44, 4, 0, 40, 0, 0, 0, 19, 0, 0, 5, 34, 0, 49, 0, 16, 12, 22, 0, 0, 0, 6, 0, 0, 0, 0, 43, 0, 0, 48, 0, 0, 0, 0, 7, 29, 27, 39, 36, 0, 0, 13, 31, 0, 0, 25, 20, 47, 17, 8, 0, 0, 0, 0, 42, 0, 0, 33, 0, 0, 0, 0, 23, 0, 0, 0, 9, 46, 14, 0, 56, 0, 55, 38, 0, 0, 54, 0, 0, 0, 35, 0, 53, 18, 41, 10, 0, 21, 0, 45, 52, 28, 0, 0, 30, 0, 26, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 16, 0, 2, 0, 0, 0, 32, 3, 0, 30, 0, 34, 0, 53, 4, 12, 48, 20, 0, 23, 28, 0, 0, 5, 36, 0, 0, 0, 41, 44, 63, 0, 62, 17, 6, 52, 61, 0, 0, 26, 13, 0, 60, 0, 0, 38, 0, 7, 47, 0, 59, 0, 0, 0, 0, 0, 0, 0, 21, 51, 58, 0, 8, 0, 0, 0, 24, 14, 18, 43, 31, 33, 57, 0, 40, 0, 0, 29, 0, 9, 35, 0, 46, 0, 0, 50, 56, 0, 0, 0, 0, 0, 27, 0, 0, 0, 15, 37, 10, 0, 0, 22, 55, 0, 0, 19, 0, 0, 0, 0, 0, 42, 0, 49, 0, 25, 0, 0, 45, 11, 54, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 38, 2, 23, 0, 20, 0, 3, 0, 50, 55, 12, 0, 43, 4, 0, 0, 0, 46, 26, 0, 0, 0, 5, 0, 17, 40, 0, 0, 0, 0, 65, 54, 64, 6, 0, 13, 63, 0, 33, 0, 49, 31, 62, 35, 0, 21, 7, 0, 0, 24, 61, 0, 29, 0, 0, 53, 37, 45, 42, 18, 60, 8, 14, 0, 0, 0, 0, 0, 0, 0, 0, 27, 59, 0, 48, 0, 0, 39, 9, 0, 0, 52, 0, 0, 0, 0, 58, 0, 22, 0, 0, 15, 0, 0, 0, 0, 19, 10, 25, 44, 0, 0, 57, 0, 32, 34, 41, 0, 0, 51, 47, 30, 0, 0, 36, 0, 0, 0, 11, 0, 56, 0, 16, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 31, 0, 2, 0, 0, 12, 62, 3, 0, 55, 0, 0, 39, 17, 4, 47, 44, 29, 0, 0, 61, 0, 0, 5, 0, 0, 24, 0, 21, 0, 13, 0, 50, 0, 6, 41, 60, 54, 0, 0, 0, 0, 27, 0, 0, 0, 0, 7, 18, 0, 0, 0, 0, 0, 59, 0, 0, 14, 34, 46, 0, 36, 8, 32, 0, 0, 43, 53, 0, 0, 49, 22, 38, 0, 58, 25, 30, 0, 0, 9, 0, 0, 0, 0, 0, 19, 15, 0, 0, 0, 0, 40, 0, 0, 0, 0, 57, 28, 10, 52, 0, 68, 0, 67, 0, 45, 0, 66, 0, 0, 48, 0, 0, 65, 0, 0, 23, 16, 42, 11, 56, 64, 0, 0, 20, 0, 26, 35, 33, 0, 0, 63, 0, 51, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 12, 59, 29, 0, 3, 0, 17, 0, 41, 0, 0, 4, 0, 0, 0, 24, 0, 0, 0, 21, 5, 0, 0, 58, 53, 13, 46, 0, 0, 27, 69, 6, 68, 49, 0, 0, 67, 43, 0, 34, 36, 18, 66, 0, 7, 0, 32, 57, 0, 38, 65, 0, 14, 0, 0, 0, 0, 0, 52, 8, 64, 30, 22, 0, 25, 0, 40, 0, 0, 0, 0, 0, 63, 56, 45, 48, 9, 0, 19, 0, 0, 15, 0, 0, 28, 0, 62, 0, 0, 0, 0, 42, 0, 0, 51, 10, 0, 0, 0, 0, 0, 55, 61, 0, 0, 0, 0, 23, 35, 0, 0, 33, 16, 37, 0, 26, 11, 20, 0, 47, 60, 0, 31, 0, 44, 0, 39, 0, 0, 0, 0, 54, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 68, 30, 56, 0, 3, 0, 0, 0, 0, 0, 0, 4, 49, 0, 67, 13, 0, 52, 0, 60, 5, 18, 0, 37, 25, 46, 39, 0, 35, 0, 66, 6, 22, 0, 28, 0, 0, 41, 0, 0, 55, 33, 14, 0, 7, 0, 0, 0, 65, 59, 0, 0, 0, 0, 0, 0, 43, 0, 19, 8, 0, 0, 31, 51, 48, 0, 0, 0, 64, 0, 0, 15, 0, 0, 0, 26, 9, 23, 0, 0, 54, 58, 0, 45, 0, 0, 0, 0, 0, 0, 63, 29, 0, 0, 0, 10, 0, 20, 38, 36, 0, 0, 16, 0, 0, 40, 0, 74, 34, 73, 0, 50, 0, 72, 62, 57, 11, 0, 47, 71, 42, 0, 53, 0, 24, 32, 0, 70, 27, 0, 0, 0, 0, 0, 0, 17, 0, 69, 21, 12, 61, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 46, 0, 2, 55, 0, 0, 59, 3, 37, 39, 0, 0, 0, 0, 4, 35, 13, 64, 41, 25, 18, 0, 0, 5, 0, 0, 0, 28, 0, 22, 33, 0, 51, 0, 6, 43, 75, 48, 74, 0, 58, 63, 73, 14, 0, 54, 0, 7, 72, 0, 0, 0, 0, 31, 0, 0, 71, 19, 0, 0, 45, 0, 8, 0, 0, 0, 70, 62, 0, 0, 26, 0, 15, 0, 23, 0, 57, 0, 69, 9, 0, 0, 50, 38, 29, 0, 36, 0, 40, 53, 0, 0, 68, 47, 0, 61, 20, 34, 10, 0, 0, 42, 0, 16, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 56, 0, 32, 0, 0, 11, 0, 24, 44, 27, 0, 60, 66, 0, 0, 0, 0, 0, 0, 0, 49, 52, 17, 21, 0, 0, 0, 0, 12, 30, 0, 0, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 72, 2, 0, 0, 0, 0, 3, 18, 47, 13, 22, 64, 0, 4, 71, 0, 31, 0, 0, 0, 0, 0, 5, 0, 59, 0, 0, 40, 38, 0, 70, 0, 52, 6, 42, 0, 14, 36, 0, 55, 0, 63, 0, 49, 19, 26, 7, 0, 69, 44, 0, 0, 0, 29, 34, 23, 0, 0, 0, 0, 0, 8, 0, 0, 58, 15, 0, 0, 68, 0, 0, 0, 46, 62, 0, 0, 0, 0, 9, 32, 0, 0, 0, 20, 0, 0, 51, 54, 0, 0, 67, 0, 0, 0, 0, 0, 16, 10, 27, 0, 0, 0, 24, 48, 0, 39, 57, 61, 41, 0, 37, 0, 30, 0, 66, 78, 0, 77, 11, 43, 0, 76, 0, 35, 21, 0, 0, 75, 0, 17, 0, 0, 0, 0, 0, 74, 0, 53, 45, 0, 65, 12, 50, 60, 33, 73, 0, 0, 0, 0, 56, 25, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 13, 0, 0, 3, 70, 0, 0, 0, 60, 34, 4, 0, 0, 0, 0, 64, 48, 0, 26, 5, 29, 0, 0, 0, 0, 0, 0, 14, 69, 19, 6, 0, 53, 56, 23, 81, 0, 80, 0, 0, 32, 79, 0, 7, 0, 41, 0, 78, 39, 50, 43, 63, 59, 0, 68, 77, 15, 0, 8, 37, 0, 0, 0, 45, 0, 76, 0, 0, 20, 0, 0, 27, 0, 0, 0, 9, 0, 75, 35, 30, 0, 24, 67, 0, 47, 55, 0, 16, 0, 62, 52, 74, 0, 0, 10, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 33, 0, 73, 0, 21, 0, 0, 66, 49, 0, 11, 0, 0, 0, 0, 17, 0, 0, 0, 0, 72, 28, 40, 42, 61, 25, 0, 0, 0, 38, 0, 0, 44, 12, 54, 31, 0, 0, 0, 65, 71, 57, 0, 0, 36, 51, 0, 22, 0, 46, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 13, 62, 2, 0, 29, 72, 26, 3, 0, 41, 43, 0, 66, 0, 4, 0, 39, 55, 0, 45, 32, 0, 58, 5, 0, 19, 23, 14, 0, 71, 52, 37, 0, 0, 6, 0, 47, 0, 0, 0, 83, 0, 82, 0, 0, 61, 81, 7, 65, 0, 0, 0, 80, 0, 35, 70, 15, 0, 0, 27, 79, 49, 8, 30, 20, 0, 0, 0, 0, 0, 78, 0, 0, 24, 57, 54, 0, 0, 0, 9, 0, 0, 77, 69, 0, 33, 64, 16, 0, 0, 0, 60, 42, 0, 51, 40, 76, 44, 10, 0, 0, 0, 0, 0, 0, 21, 38, 0, 0, 0, 46, 0, 75, 68, 28, 0, 0, 0, 0, 11, 17, 0, 25, 0, 31, 36, 63, 0, 56, 0, 74, 48, 0, 0, 0, 53, 0, 0, 0, 59, 0, 0, 12, 0, 0, 67, 0, 0, 22, 0, 73, 0, 34, 0, 0, 18, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 51, 0, 0, 3, 23, 0, 0, 79, 35, 19, 4, 0, 0, 0, 0, 59, 56, 14, 71, 5, 0, 0, 0, 78, 0, 66, 0, 44, 42, 30, 6, 27, 62, 0, 46, 53, 0, 40, 0, 0, 0, 77, 0, 7, 0, 33, 15, 0, 20, 48, 70, 24, 0, 0, 38, 0, 0, 0, 8, 0, 0, 76, 0, 0, 0, 0, 0, 65, 0, 0, 0, 58, 50, 0, 0, 9, 0, 16, 55, 36, 0, 0, 61, 75, 69, 0, 28, 0, 0, 21, 31, 0, 0, 0, 10, 0, 0, 0, 0, 0, 25, 0, 0, 52, 0, 0, 0, 74, 0, 0, 17, 64, 34, 43, 0, 11, 45, 0, 41, 0, 68, 0, 0, 0, 86, 0, 85, 47, 0, 57, 84, 39, 22, 73, 60, 0, 83, 0, 12, 0, 0, 0, 54, 29, 82, 18, 49, 0, 0, 0, 0, 26, 37, 32, 81, 0, 0, 63, 67, 0, 0, 72, 0, 13, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 19, 2, 30, 0, 0, 0, 3, 0, 0, 38, 27, 67, 33, 4, 14, 0, 52, 60, 0, 77, 0, 0, 5, 0, 57, 0, 71, 0, 63, 0, 0, 0, 0, 6, 0, 0, 24, 0, 0, 20, 36, 0, 89, 15, 88, 76, 7, 0, 87, 54, 0, 0, 0, 45, 86, 0, 43, 66, 47, 0, 0, 8, 85, 31, 70, 28, 0, 41, 0, 0, 0, 49, 84, 75, 16, 0, 0, 59, 9, 34, 21, 0, 62, 0, 83, 25, 39, 0, 0, 0, 56, 0, 51, 0, 0, 0, 0, 10, 82, 0, 0, 0, 0, 74, 69, 65, 0, 17, 0, 0, 0, 0, 0, 37, 81, 0, 0, 0, 11, 0, 0, 53, 29, 22, 0, 0, 32, 0, 0, 0, 0, 0, 80, 0, 0, 73, 26, 0, 61, 58, 0, 12, 18, 44, 46, 0, 68, 0, 35, 0, 42, 0, 79, 48, 0, 64, 0, 0, 55, 0, 0, 0, 0, 0, 0, 40, 13, 0, 23, 72, 50, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 33, 2, 27, 0, 0, 0, 3, 0, 83, 66, 70, 75, 14, 4, 0, 0, 0, 54, 0, 0, 0, 0, 5, 0, 82, 0, 36, 0, 0, 0, 24, 45, 0, 6, 47, 20, 43, 0, 0, 59, 62, 15, 81, 74, 0, 49, 7, 0, 0, 41, 0, 0, 69, 31, 0, 0, 56, 28, 0, 65, 0, 8, 80, 0, 51, 0, 0, 34, 0, 0, 39, 0, 16, 0, 0, 0, 21, 73, 9, 25, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 0, 68, 10, 61, 37, 0, 0, 0, 58, 0, 17, 0, 0, 78, 0, 0, 64, 0, 72, 29, 0, 32, 0, 11, 22, 0, 0, 46, 44, 0, 0, 55, 0, 0, 48, 26, 0, 42, 90, 77, 89, 35, 0, 0, 88, 18, 12, 67, 0, 50, 87, 0, 0, 0, 40, 0, 71, 0, 86, 0, 0, 0, 0, 60, 0, 0, 0, 76, 85, 23, 63, 13, 52, 0, 57, 0, 0, 0, 30, 38, 84, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 57, 24, 2, 14, 31, 0, 77, 3, 34, 0, 48, 83, 0, 46, 4, 50, 20, 0, 28, 0, 0, 65, 62, 5, 44, 72, 0, 0, 52, 0, 37, 0, 15, 0, 6, 0, 0, 82, 68, 0, 0, 59, 0, 42, 76, 0, 95, 7, 94, 54, 25, 0, 93, 0, 0, 0, 0, 21, 92, 0, 0, 0, 8, 16, 0, 81, 91, 32, 0, 0, 40, 0, 0, 71, 0, 29, 90, 35, 56, 9, 0, 0, 0, 64, 75, 0, 0, 0, 89, 0, 61, 0, 0, 0, 67, 80, 17, 0, 10, 0, 22, 26, 88, 0, 0, 38, 47, 49, 0, 0, 0, 0, 0, 45, 0, 58, 51, 0, 87, 11, 0, 0, 0, 70, 0, 0, 74, 79, 43, 0, 0, 18, 33, 53, 30, 0, 86, 0, 0, 0, 0, 0, 12, 0, 0, 23, 0, 63, 36, 0, 0, 41, 66, 0, 27, 0, 85, 0, 55, 0, 60, 78, 0, 0, 0, 0, 0, 13, 19, 0, 73, 0, 0, 0, 0, 69, 0, 0, 84, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 52, 14, 2, 0, 44, 59, 89, 3, 0, 0, 28, 0, 20, 0, 4, 0, 37, 0, 0, 54, 0, 71, 88, 5, 0, 42, 75, 0, 0, 80, 15, 0, 0, 0, 6, 0, 0, 0, 0, 0, 87, 64, 0, 0, 25, 0, 56, 7, 67, 0, 0, 0, 61, 21, 40, 0, 0, 32, 0, 0, 86, 16, 8, 79, 0, 35, 0, 29, 0, 0, 74, 0, 0, 70, 0, 0, 0, 0, 0, 9, 0, 58, 85, 49, 47, 0, 0, 0, 0, 0, 51, 38, 0, 45, 17, 26, 22, 0, 10, 78, 0, 0, 0, 0, 0, 53, 84, 63, 66, 0, 43, 0, 0, 0, 0, 0, 73, 0, 0, 11, 0, 0, 33, 0, 60, 0, 30, 69, 55, 18, 0, 0, 83, 0, 0, 41, 36, 77, 0, 0, 0, 23, 12, 96, 0, 95, 0, 0, 27, 94, 0, 0, 0, 0, 0, 93, 0, 0, 0, 57, 82, 0, 0, 92, 72, 0, 19, 13, 39, 0, 65, 0, 0, 91, 0, 62, 0, 76, 0, 48, 0, 0, 50, 68, 46, 90, 0, 31, 24, 34, 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 0, 20, 91, 0, 3, 73, 0, 0, 0, 0, 58, 4, 0, 0, 77, 0, 0, 66, 90, 40, 5, 82, 0, 15, 63, 0, 0, 0, 69, 25, 0, 6, 49, 0, 32, 51, 89, 47, 35, 0, 0, 0, 21, 0, 7, 0, 53, 0, 29, 60, 45, 0, 0, 0, 16, 81, 88, 72, 76, 8, 38, 0, 0, 0, 0, 55, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 9, 0, 87, 0, 26, 0, 0, 65, 0, 22, 0, 17, 68, 0, 0, 80, 57, 0, 0, 10, 62, 0, 0, 33, 41, 0, 86, 0, 75, 0, 0, 30, 0, 36, 0, 71, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 59, 85, 79, 23, 50, 48, 27, 0, 0, 0, 39, 52, 12, 0, 46, 0, 98, 0, 97, 0, 0, 0, 96, 67, 64, 74, 54, 0, 95, 84, 0, 44, 19, 0, 0, 0, 94, 13, 0, 34, 70, 31, 78, 61, 0, 0, 93, 0, 0, 56, 24, 0, 0, 0, 0, 37, 42, 0, 92, 83, 0, 28, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 20, 0, 2, 76, 0, 87, 40, 3, 72, 0, 0, 49, 51, 0, 4, 0, 60, 0, 47, 0, 0, 53, 0, 5, 15, 0, 25, 32, 0, 35, 80, 86, 0, 45, 6, 0, 0, 0, 55, 0, 0, 21, 0, 29, 65, 68, 0, 7, 99, 38, 98, 75, 0, 0, 97, 16, 43, 0, 0, 85, 96, 62, 8, 57, 71, 0, 0, 0, 95, 0, 79, 0, 0, 0, 0, 0, 0, 26, 94, 9, 0, 0, 0, 0, 22, 0, 0, 41, 17, 84, 93, 0, 33, 0, 0, 0, 59, 0, 10, 0, 36, 74, 30, 0, 92, 0, 0, 0, 0, 67, 50, 0, 78, 48, 64, 52, 0, 0, 0, 11, 91, 83, 70, 18, 46, 0, 39, 0, 54, 23, 27, 0, 0, 0, 0, 0, 0, 61, 90, 0, 0, 0, 12, 44, 0, 0, 0, 0, 0, 56, 0, 0, 0, 73, 0, 82, 77, 0, 89, 34, 19, 0, 0, 31, 0, 0, 0, 13, 0, 0, 42, 0, 0, 37, 0, 66, 24, 0, 58, 0, 88, 0, 69, 0, 0, 28, 63, 0, 0, 0, 0, 81, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 2, 65, 46, 0, 0, 3, 0, 86, 0, 60, 15, 0, 4, 0, 0, 21, 81, 77, 0, 0, 92, 5, 0, 0, 0, 0, 36, 0, 0, 0, 33, 0, 6, 44, 0, 0, 0, 0, 0, 26, 39, 16, 62, 70, 0, 7, 0, 85, 91, 105, 73, 104, 30, 0, 67, 103, 0, 0, 22, 0, 8, 102, 53, 0, 0, 51, 80, 55, 0, 101, 0, 0, 42, 0, 17, 76, 49, 9, 90, 100, 57, 0, 0, 64, 0, 0, 0, 0, 0, 84, 0, 99, 27, 0, 0, 47, 10, 34, 0, 37, 0, 59, 0, 23, 0, 98, 0, 0, 0, 18, 89, 0, 0, 31, 0, 69, 72, 11, 79, 40, 0, 97, 45, 0, 0, 0, 0, 0, 0, 0, 61, 0, 66, 83, 0, 75, 0, 0, 0, 96, 12, 0, 0, 0, 88, 0, 19, 28, 0, 0, 24, 0, 0, 0, 0, 0, 0, 43, 0, 95, 0, 0, 0, 0, 0, 13, 35, 63, 52, 54, 0, 0, 78, 0, 38, 50, 32, 0, 56, 82, 87, 94, 0, 0, 71, 20, 0, 0, 0, 68, 48, 0, 14, 0, 0, 58, 0, 74, 0, 25, 41, 0, 0, 0, 29, 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 15, 0, 2, 0, 0, 26, 30, 3, 0, 0, 0, 0, 56, 98, 4, 54, 45, 58, 0, 0, 0, 0, 0, 5, 0, 0, 52, 67, 91, 37, 60, 16, 82, 0, 6, 86, 22, 40, 0, 34, 0, 97, 0, 0, 0, 50, 0, 7, 75, 0, 0, 62, 0, 72, 111, 0, 110, 0, 27, 0, 109, 78, 8, 43, 17, 0, 108, 31, 0, 0, 90, 96, 48, 0, 107, 0, 69, 0, 0, 9, 64, 23, 0, 0, 106, 0, 0, 85, 0, 0, 0, 0, 81, 0, 0, 0, 105, 0, 10, 18, 0, 0, 0, 95, 38, 0, 0, 46, 35, 0, 104, 0, 0, 28, 89, 0, 0, 66, 41, 11, 0, 0, 74, 0, 55, 57, 103, 0, 24, 77, 32, 53, 0, 71, 59, 0, 19, 94, 0, 0, 0, 84, 12, 0, 102, 0, 51, 0, 0, 0, 44, 61, 0, 0, 80, 0, 0, 0, 0, 0, 88, 0, 68, 0, 101, 0, 0, 13, 0, 49, 29, 0, 0, 93, 0, 20, 63, 25, 0, 36, 0, 39, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 14, 33, 0, 83, 73, 76, 47, 42, 0, 0, 0, 0, 0, 0, 87, 65, 99, 92, 0, 0, 0, 70, 21, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 50, 2, 0, 0, 37, 0, 3, 64, 40, 100, 0, 0, 0, 4, 0, 0, 84, 0, 34, 0, 93, 0, 5, 88, 77, 74, 16, 22, 0, 0, 43, 48, 0, 6, 0, 0, 0, 99, 0, 0, 66, 80, 0, 0, 71, 27, 7, 0, 0, 0, 31, 0, 0, 0, 113, 0, 112, 0, 0, 17, 111, 8, 92, 0, 0, 0, 110, 98, 57, 0, 46, 55, 23, 59, 109, 87, 83, 0, 9, 38, 0, 68, 53, 0, 108, 0, 61, 35, 0, 41, 0, 0, 0, 0, 18, 0, 107, 10, 76, 97, 28, 51, 0, 0, 0, 73, 91, 63, 0, 79, 106, 0, 0, 32, 0, 0, 0, 44, 11, 24, 0, 0, 0, 0, 0, 0, 105, 0, 49, 86, 70, 19, 0, 96, 0, 0, 65, 0, 82, 0, 0, 12, 0, 0, 104, 0, 0, 0, 0, 0, 0, 0, 90, 0, 0, 0, 39, 29, 36, 0, 0, 0, 0, 47, 103, 0, 13, 0, 25, 95, 20, 0, 42, 67, 75, 0, 0, 0, 33, 78, 0, 0, 56, 58, 0, 85, 102, 72, 0, 54, 0, 0, 60, 14, 0, 0, 0, 0, 0, 0, 89, 0, 81, 0, 52, 0, 45, 94, 0, 62, 101, 21, 0, 0, 0, 0, 30, 0, 69, 26, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 71, 2, 66, 0, 0, 0, 3, 0, 34, 87, 0, 48, 106, 4, 43, 0, 83, 97, 0, 0, 0, 0, 5, 22, 16, 0, 0, 0, 0, 0, 105, 0, 0, 6, 91, 0, 0, 0, 0, 27, 57, 68, 31, 59, 0, 55, 7, 0, 76, 0, 104, 0, 46, 96, 61, 79, 0, 17, 53, 73, 0, 8, 0, 0, 0, 86, 0, 38, 23, 0, 0, 0, 103, 63, 0, 41, 0, 35, 9, 51, 82, 0, 90, 0, 0, 0, 0, 0, 70, 0, 0, 95, 18, 0, 28, 0, 102, 10, 0, 0, 65, 44, 0, 0, 0, 32, 0, 0, 49, 0, 0, 0, 0, 0, 0, 24, 0, 0, 11, 0, 0, 0, 101, 85, 0, 0, 75, 78, 0, 19, 0, 94, 89, 0, 0, 67, 0, 0, 0, 0, 0, 12, 0, 72, 39, 47, 81, 0, 36, 0, 100, 29, 0, 0, 0, 58, 56, 0, 42, 0, 0, 0, 60, 0, 25, 54, 13, 0, 20, 114, 33, 113, 0, 93, 0, 112, 0, 62, 69, 0, 99, 111, 52, 84, 88, 0, 0, 0, 0, 110, 45, 0, 0, 14, 0, 0, 0, 0, 0, 109, 64, 77, 0, 0, 0, 0, 74, 50, 0, 21, 30, 108, 98, 0, 80, 26, 0, 92, 0, 0, 0, 37, 15, 40, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 85, 0, 2, 0, 0, 70, 63, 3, 0, 0, 0, 53, 108, 99, 4, 0, 22, 46, 0, 0, 0, 16, 0, 5, 78, 0, 93, 31, 27, 65, 107, 75, 0, 0, 6, 81, 51, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 7, 41, 98, 106, 0, 0, 88, 17, 0, 72, 0, 35, 0, 67, 23, 8, 0, 84, 0, 0, 0, 0, 49, 44, 0, 105, 0, 92, 0, 0, 0, 0, 9, 0, 0, 0, 28, 0, 0, 0, 97, 0, 18, 32, 0, 0, 0, 0, 0, 104, 0, 10, 69, 58, 0, 77, 60, 0, 56, 0, 80, 24, 0, 47, 87, 0, 0, 62, 74, 0, 0, 54, 11, 0, 39, 103, 0, 91, 0, 19, 96, 0, 36, 83, 42, 0, 64, 0, 0, 0, 0, 0, 52, 29, 0, 12, 0, 0, 0, 71, 0, 0, 0, 102, 0, 0, 0, 0, 33, 0, 25, 0, 45, 66, 0, 0, 0, 0, 20, 0, 13, 50, 95, 0, 86, 0, 116, 0, 115, 90, 0, 0, 114, 101, 79, 76, 0, 0, 113, 0, 0, 0, 0, 0, 0, 0, 112, 14, 68, 0, 0, 82, 30, 40, 73, 37, 111, 0, 48, 21, 0, 26, 0, 0, 0, 100, 94, 0, 110, 43, 59, 57, 0, 0, 0, 34, 15, 61, 0, 0, 55, 0, 109, 89, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 99, 106, 2, 31, 22, 0, 41, 3, 38, 49, 27, 0, 0, 60, 4, 16, 58, 0, 62, 0, 71, 0, 44, 5, 0, 79, 0, 56, 35, 105, 82, 64, 89, 0, 6, 0, 0, 0, 76, 0, 0, 0, 98, 93, 0, 0, 54, 7, 17, 23, 0, 0, 66, 85, 0, 0, 47, 0, 119, 104, 118, 0, 8, 0, 117, 28, 32, 0, 0, 73, 116, 0, 0, 52, 0, 0, 0, 0, 115, 9, 0, 68, 0, 18, 0, 39, 97, 0, 114, 42, 0, 103, 0, 0, 88, 0, 24, 92, 10, 36, 113, 0, 0, 0, 0, 0, 81, 78, 50, 0, 0, 45, 0, 0, 112, 0, 0, 0, 70, 11, 19, 0, 29, 84, 0, 102, 75, 0, 0, 0, 111, 33, 96, 59, 61, 0, 0, 0, 0, 0, 57, 0, 12, 63, 0, 25, 0, 0, 110, 0, 0, 48, 0, 91, 0, 55, 0, 0, 87, 20, 65, 101, 0, 72, 40, 0, 0, 13, 109, 0, 0, 0, 37, 0, 43, 0, 0, 0, 53, 0, 95, 30, 0, 0, 80, 67, 0, 0, 0, 0, 108, 77, 0, 0, 14, 83, 26, 0, 34, 100, 21, 0, 46, 0, 0, 0, 0, 0, 0, 51, 0, 90, 0, 0, 107, 0, 74, 0, 69, 0, 0, 0, 0, 15, 86, 0, 0, 0, 0, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 22, 56, 2, 103, 27, 0, 44, 3, 97, 0, 112, 0, 0, 16, 4, 0, 66, 0, 35, 0, 0, 0, 54, 5, 0, 73, 0, 92, 111, 0, 88, 0, 0, 0, 6, 0, 0, 0, 47, 102, 0, 0, 0, 68, 0, 23, 17, 7, 110, 0, 0, 52, 81, 0, 0, 0, 96, 78, 32, 28, 0, 0, 8, 0, 0, 84, 0, 0, 0, 0, 109, 0, 0, 39, 0, 42, 0, 101, 70, 9, 75, 18, 0, 0, 0, 91, 0, 0, 50, 36, 0, 0, 24, 0, 108, 45, 87, 0, 10, 0, 0, 0, 0, 0, 61, 59, 95, 0, 0, 0, 0, 63, 0, 0, 57, 0, 29, 100, 19, 11, 107, 72, 0, 33, 0, 0, 65, 0, 0, 0, 0, 55, 80, 48, 0, 0, 0, 0, 0, 83, 0, 25, 12, 77, 0, 90, 0, 0, 106, 67, 0, 0, 40, 0, 0, 0, 53, 20, 94, 99, 43, 0, 37, 0, 86, 0, 0, 13, 0, 0, 0, 0, 74, 0, 0, 30, 0, 0, 105, 120, 69, 119, 0, 0, 0, 118, 46, 0, 0, 51, 34, 117, 26, 0, 14, 0, 0, 0, 21, 116, 0, 0, 0, 98, 0, 0, 0, 89, 0, 115, 104, 0, 93, 0, 79, 82, 0, 0, 0, 71, 0, 114, 0, 15, 60, 0, 0, 62, 0, 58, 49, 76, 0, 41, 85, 113, 31, 38, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 76, 2, 16, 0, 42, 0, 3, 0, 0, 99, 55, 0, 39, 4, 45, 0, 0, 32, 71, 111, 104, 0, 5, 0, 23, 84, 0, 0, 28, 0, 0, 0, 81, 6, 0, 17, 87, 0, 36, 0, 0, 0, 48, 0, 0, 53, 7, 0, 94, 110, 0, 0, 0, 0, 0, 73, 0, 78, 0, 0, 125, 8, 124, 98, 103, 90, 123, 0, 0, 0, 18, 24, 122, 0, 0, 0, 62, 64, 9, 0, 121, 109, 33, 60, 0, 29, 66, 0, 51, 43, 120, 40, 0, 0, 0, 0, 0, 10, 58, 0, 75, 0, 119, 68, 0, 46, 0, 19, 0, 83, 102, 37, 93, 0, 86, 108, 118, 0, 11, 97, 25, 56, 80, 0, 0, 0, 0, 0, 70, 0, 0, 0, 117, 0, 0, 0, 0, 89, 0, 49, 0, 12, 0, 0, 30, 0, 20, 0, 0, 34, 116, 107, 54, 77, 0, 0, 0, 0, 101, 0, 0, 72, 0, 0, 0, 0, 13, 0, 0, 0, 115, 26, 41, 0, 0, 0, 44, 96, 92, 0, 0, 0, 0, 0, 0, 0, 38, 21, 0, 106, 0, 52, 114, 14, 85, 82, 0, 0, 47, 0, 0, 63, 74, 0, 61, 31, 65, 0, 100, 0, 0, 88, 0, 0, 79, 59, 113, 0, 35, 67, 0, 0, 15, 0, 27, 0, 0, 0, 0, 105, 22, 0, 0, 0, 57, 0, 0, 95, 50, 0, 69, 0, 112, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0 } };


#if (defined(GCC_ASM64X) || defined(__MINGW64__)) && !defined(FORCE_GENERIC) && !defined(TARGET_KNC)
	#define SM_SCAN_CLEAN asm volatile("emms");	
	#define SM_SIMD_SIEVE_SCAN_VEC 1


uint32 mulredc32(uint32 x, uint32 y, uint32 n, uint32 nhat)
{
    ASM_G(
        "mull %2	\n\t"
        "movl %%eax, %%r10d		\n\t"
        "movl %%edx, %%r11d		\n\t"
        "mull %3 \n\t"
        "mull %4 \n\t"
        "addl %%r10d, %%eax \n\t"
        "adcl %%r11d, %%edx \n\t"
        "xorl %%eax, %%eax \n\t"
        "subl %4, %%edx \n\t"
        "cmovc %4, %%eax \n\t"
        "addl %%edx, %%eax \n\t"
        : "=a"(x)
        : "0"(x), "r"(y), "r"(nhat), "r"(n)
        : "edx", "r10", "r11", "cc");

    return x;
}

uint32 u32div(uint32 c, uint32 n)
{
    ASM_G("divl %4"
        : "=a"(c), "=d"(n)
        : "1"(c), "0"(0), "r"(n));

    return n;
}


#ifdef USE_AVX2

#define SM_SIEVE_SCAN_64_VEC					\
		asm volatile (							\
			"vmovdqa (%1), %%ymm0   \n\t"		\
			"vpor 32(%1), %%ymm0, %%ymm0    \n\t"		\
			"vpmovmskb %%ymm0, %%r11   \n\t"	/* output results to 64 bit register */		\
			"testq %%r11, %%r11 \n\t"			/* AND, and set ZF */ \
			"jz 2f	\n\t"						/* jump out if zero (no hits).  high percentage. */ \
			"vmovdqa (%1), %%ymm0   \n\t"		/* else, we had hits, move sections of sieveblock back in */ \
			"vmovdqa 32(%1), %%ymm1   \n\t"		/* extract high bit masks from each byte */ \
			"vpmovmskb %%ymm1, %%r9d   \n\t"		/*  */		\
			"salq $32, %%r9		\n\t"			/*  */ \
			"vpmovmskb %%ymm0, %%r8d   \n\t"		/*  */		\
			"orq	%%r9,%%r8		\n\t"		/* r8 now holds 64 byte mask results, in order, from sieveblock */ \
			"xorq	%%r11,%%r11		\n\t"		/* initialize count of set bits */ \
			"xorq	%%r10,%%r10		\n\t"		/* initialize bit scan offset */ \
			"1:			\n\t"					/* top of bit scan loop */ \
			"bsfq	%%r8,%%rcx		\n\t"		/* put least significant set bit index into rcx */ \
			"addq	%%rcx,%%r10	\n\t"			/* add in the offset of this index */ \
			"movb	%%r10b, (%2, %%r11, 1) \n\t"		/* put the bit index into the output buffer */ \
			"shrq	%%cl,%%r8	\n\t"			/* shift the bit scan register up to the bit we just processed */ \
			"incq	%%r11		\n\t"			/* increment the count of set bits */ \
            "incq	%%r10		\n\t"			/* increment the index */ \
			"shrq	$1, %%r8 \n\t"				/* clear the bit */ \
			"testq	%%r8,%%r8	\n\t"			/* check if there are any more set bits */ \
			"jnz 1b		\n\t"					/* loop if so */ \
			"2:		\n\t"						/*  */ \
			"movl	%%r11d, %0 \n\t"			/* return the count of set bits */ \
			: "=r"(result)						\
			: "r"(sieveblock + j), "r"(buffer)	\
			: "xmm0", "xmm1", "r8", "r9", "r10", "r11", "rcx", "cc", "memory");

#else

	#define SM_SIEVE_SCAN_64_VEC					\
		asm volatile (							\
			"movdqa (%1), %%xmm0   \n\t"		\
			"por 16(%1), %%xmm0    \n\t"		\
			"por 32(%1), %%xmm0    \n\t"		\
			"por 48(%1), %%xmm0    \n\t"		\
			"pmovmskb %%xmm0, %%r11   \n\t"		/* output results to 64 bit register */		\
			"testq %%r11, %%r11 \n\t"			/* AND, and set ZF */ \
			"jz 2f	\n\t"						/* jump out if zero (no hits).  high percentage. */ \
			"movdqa (%1), %%xmm0   \n\t"		/* else, we had hits, move sections of sieveblock back in */ \
			"movdqa 16(%1), %%xmm1   \n\t"		/* there are 16 bytes in each section */ \
			"movdqa 32(%1), %%xmm2   \n\t"		/* extract high bit masks from each byte */ \
			"movdqa 48(%1), %%xmm3   \n\t"		/* and combine into one 64 bit register */ \
			"pmovmskb %%xmm1, %%r9d   \n\t"		/*  */		\
			"pmovmskb %%xmm3, %%r11d   \n\t"	/*  */		\
			"salq $16, %%r9		\n\t"			/*  */ \
			"pmovmskb %%xmm2, %%r10d   \n\t"	/*  */		\
			"salq $48, %%r11		\n\t"		/*  */ \
			"pmovmskb %%xmm0, %%r8d   \n\t"		/*  */		\
			"salq $32, %%r10		\n\t"		/*  */ \
			"orq	%%r11,%%r9		\n\t"		/*  */ \
			"orq	%%r10,%%r8		\n\t"		/*  */ \
			"xorq	%%r11,%%r11		\n\t"		/* initialize count of set bits */ \
			"orq	%%r9,%%r8		\n\t"		/* r8 now holds 64 byte mask results, in order, from sieveblock */ \
			"xorq	%%r10,%%r10		\n\t"		/* initialize bit scan offset */ \
			"1:			\n\t"					/* top of bit scan loop */ \
			"bsfq	%%r8,%%rcx		\n\t"		/* put least significant set bit index into rcx */ \
            "jz 2f	\n\t"						/* jump out if zero (no hits).  high percentage. */ \
			"addq	%%rcx,%%r10	\n\t"			/* add in the offset of this index */ \
			"movb	%%r10b, (%2, %%r11, 1) \n\t"		/* put the bit index into the output buffer */ \
			"shrq	%%cl,%%r8	\n\t"			/* shift the bit scan register up to the bit we just processed */ \
			"incq	%%r11		\n\t"			/* increment the count of set bits */ \
            "incq	%%r10		\n\t"			/* increment the index */ \
			"shrq	$1, %%r8 \n\t"				/* clear the bit */ \
			"jmp 1b		\n\t"					/* loop if so */ \
			"2:		\n\t"						/*  */ \
			"movl	%%r11d, %0 \n\t"			/* return the count of set bits */ \
			: "=r"(result)						\
			: "r"(sieveblock + j), "r"(buffer)	\
			: "xmm0", "xmm1", "xmm2", "xmm3", "r8", "r9", "r10", "r11", "rcx", "cc", "memory");

#endif

#elif (defined(GCC_ASM32X) || defined(__MINGW32__)) && !defined(FORCE_GENERIC)
	#define SM_SCAN_CLEAN asm volatile("emms");	
	#define SM_SIMD_SIEVE_SCAN 1

	#define SM_SIEVE_SCAN_64		\
		asm volatile (							\
			"movdqa (%1), %%xmm0   \n\t"		\
			"orpd 16(%1), %%xmm0    \n\t"		\
			"orpd 32(%1), %%xmm0    \n\t"		\
			"orpd 48(%1), %%xmm0    \n\t"		\
			"pmovmskb %%xmm0, %0   \n\t"		\
			: "=r"(result)						\
			: "r"(sieveblock + j), "0"(result)	\
			: "xmm0");


    __inline uint32 mulredc32(uint32 x, uint32 y, uint32 n, uint32 nhat)
    {
        ASM_G(
            "mull %2	\n\t"
            "movl %%eax, %%r10d		\n\t"
            "movl %%edx, %%r11d		\n\t"
            "mull %3 \n\t"
            "mull %4 \n\t"
            "addl %%r10d, %%eax \n\t"
            "adcl %%r11d, %%edx \n\t"
            "xorl %%eax, %%eax \n\t"
            "subl %4, %%edx \n\t"
            "cmovc %4, %%eax \n\t"
            "addl %%edx, %%eax \n\t"
            : "=a"(x)
            : "0"(x), "r"(y), "r"(nhat), "r"(n)
            : "edx", "r10", "r11", "cc");

        return x;
    }

    __inline uint32 u32div(uint32 c, uint32 n)
    {
        ASM_G("divl %4"
            : "=a"(c), "=d"(n)
            : "1"(c), "0"(0), "r"(n));

        return n;
    }

#elif defined(MSC_ASM32A) && !defined(FORCE_GENERIC)
	#define SM_SCAN_CLEAN ASM_M {emms};
	#define SM_SIMD_SIEVE_SCAN 1

	#define SM_SIEVE_SCAN_64	\
		do	{						\
			uint64 *localblock = sieveblock + j;	\
			ASM_M  {			\
				ASM_M mov edi, localblock			\
				ASM_M movdqa xmm0, XMMWORD PTR [edi]	\
				ASM_M por xmm0, XMMWORD PTR [edi + 16]	\
				ASM_M por xmm0, XMMWORD PTR [edi + 32]	\
				ASM_M por xmm0, XMMWORD PTR [edi + 48]	\
				ASM_M pmovmskb ecx, xmm0			\
				ASM_M mov result, ecx};			\
		} while (0);

uint32 mulredc32(uint32 x, uint32 y, uint32 n, uint32 nhat)
{
    uint64 xx, yy;

    xx = (uint64)x * (uint64)y;
    yy = (xx & 0xffffffff) * (uint64)nhat;
    yy = (yy & 0xffffffff) * (uint64)n;
    yy += xx;
    yy >>= 32;
    if (yy >= n) yy -= n;

    return (uint32)yy;
}

uint32 u32div(uint32 c, uint32 n)
{
    return ((uint64)c << 32) % (uint64)n;
}


#elif defined(_WIN64) && !defined(FORCE_GENERIC)
	#define SM_SCAN_CLEAN /*nothing*/
	#define SM_SIMD_SIEVE_SCAN 1

	#define SM_SIEVE_SCAN_64	\
		do	{				  		\
			__m128i local_block;	\
			__m128i local_block2;	\
			__m128i local_block3;	\
			__m128i local_block4;	\
			local_block = _mm_load_si128(sieveblock + j); \
			local_block2 = _mm_load_si128(sieveblock + j + 2); \
			local_block3 = _mm_load_si128(sieveblock + j + 4); \
			local_block = _mm_or_si128(local_block, local_block2); \
			local_block = _mm_or_si128(local_block, local_block3); \
			local_block4 = _mm_load_si128(sieveblock + j + 6); \
			local_block = _mm_or_si128(local_block, local_block4); \
			result = _mm_movemask_epi8(local_block); \
		} while (0);

uint32 mulredc32(uint32 x, uint32 y, uint32 n, uint32 nhat)
{
    uint64 xx, yy;

    xx = (uint64)x * (uint64)y;
    yy = (xx & 0xffffffff) * (uint64)nhat;
    yy = (yy & 0xffffffff) * (uint64)n;
    yy += xx;
    yy >>= 32;
    if (yy >= n) yy -= n;

    return (uint32)yy;
}

uint32 u32div(uint32 c, uint32 n)
{
    return ((uint64)c << 32) % (uint64)n;
}



#else	/* compiler not recognized*/

	#define SM_SCAN_CLEAN /*nothing*/
	#undef SM_SIMD_SIEVE_SCAN
	#undef SM_SIMD_SIEVE_SCAN_VEC

uint32 mulredc32(uint32 x, uint32 y, uint32 n, uint32 nhat)
{
    uint64 xx, yy;

    xx = (uint64)x * (uint64)y;
    yy = (xx & 0xffffffff) * (uint64)nhat;
    yy = (yy & 0xffffffff) * (uint64)n;
    yy += xx;
    yy >>= 32;
    if (yy >= n) yy -= n;

    return (uint32)yy;
}

uint32 u32div(uint32 c, uint32 n)
{
    return ((uint64)c << 32) % (uint64)n;
}


#endif
#define SM_SCAN_MASK 0x8080808080808080ULL

//uint64 total_locs;
//uint64 td_locs;

sm_mpqs_params sm_sieve_params;
#define SM_MAX_SMOOTH_PRIMES 100

void smpqs_make_fb_mpqs(fb_list_sm_mpqs *fb, uint32 *modsqrt, mpz_t n)
{
	// finds the factor base primes, and computes the solutions to the congruence x^2 = N mod p
	// for the QS, these are the starting positions of the sieve relative to the sqrt of N.
	// for the MPQS, additional work using the polynomial coefficents and these congruences 
	// needs to be done to compute the starting positions of the sieve.

	int i;
	uint32 b,j,r,k;
	uint32 prime, root1;
	mpz_t tmpr;
	int bits_n = mpz_sizeinbase(n,2);

	mpz_init(tmpr);

	// the 0th element in the fb is always  2, so start searching with 3
	j=2; i=1;
	while (j<fb->B)
	{
		r = mpz_tdiv_ui(n, (fp_digit)spSOEprimes[i]);
		if (r == 0)
		{
			// p divides n, which means it divides the multiplier.
			// we can still use it, but it only has one solution to x^2 == n mod p instead
			// of two.  just divide its logprime in half.
			// we also can't find the root using shanks-tonelli, but it will be very small
			// because the multiplier is very small, so just use brute force.
			prime = (uint32)spSOEprimes[i];
            if (prime < 256)
            {
                k = small_sqrt_tab[i][r];
            }
            else
            {
                k = 0;
                while (1)
                {
                    if (((k*k) % prime) == r)
                        break;
                    k++;
                }
            }
			root1 = k;

			// fill in factor base
			fb->list->prime[j] = prime;
			modsqrt[j] = root1;			

            // store a couple things so we can replace single precision
            // mods with shifts and muls during trial division
            fb->list->small_inv[j] = small_inv_tab[i][0];
            fb->list->logprime[j] = small_inv_tab[i][2]/2;

			j++;
			i++;
			continue;
		}

		mpz_set_ui(tmpr, r);
		b = mpz_kronecker_ui(tmpr, spSOEprimes[i]);
		if (b==1)
		{
			// this prime works
			prime = (uint32)spSOEprimes[i];

            if (prime < 256)
            {
                k = small_sqrt_tab[i][r];
            }
            else
            {
                if (bits_n > 80)
                {
                    fp_digit kk;
                    ShanksTonelli_1((fp_digit)r, (fp_digit)prime, &kk);
                    k = (uint32)kk;
                }
                else
                {
                    // with small n and small factor bases, its faster to brute force it.
                    k = 0;
                    while (1)
                    {
                        if (((k*k) % prime) == r)
                            break;
                        k++;
                    }
                }
            }
			root1 = (uint32)k;

			//fill in factor base
			fb->list->prime[j] = prime;
			modsqrt[j] = root1;

			//store a couple things so we can replace single precision
			//mods with shifts and muls during trial division
            fb->list->small_inv[j] = small_inv_tab[i][0];
            fb->list->logprime[j] = small_inv_tab[i][2];
			
			j++;
		}
		i++;
	}

	mpz_clear(tmpr);
	return;
}

#define SM_NUM_PARAM_ROWS 10
void sm_get_params(int bits, uint32 *B, uint32 *M, uint32 *BL)
{
	int i;
	double scale;

	//parameter table
	//bits, fb primes, lp mulitplier, 64k blocks
	//adjustment in v1.27 - more primes and less blocks for numbers > ~80 digits
	//also different scaling for numbers bigger than 100 digits (constant increase
	//of 20% per line)
	int param_table[SM_NUM_PARAM_ROWS][4] = {
		{50,	30,	30,	1},
		{60,	36,	50,	1},
		{70,	50,	50,	1},
		{80,	80,	50,	1},
		{90,	120,	50,	1},
		{100,	150,	50,	1},
		{110,	250,	50,	1},	
		{120,	350,	60,	1},
		{130,	450,	80,	1},
	};

	//linear interpolation according to bit size to determine
	//factor base bound.  use the closest parameter for lp multiplier
	//and number of blocks.

	*B = 0;
	if (bits <= param_table[0][0])
	{
		scale = (double)bits / (double)param_table[0][0];
		*B = (uint32)(scale * (double)(param_table[0][1]));		
		*M = 50;
		*BL = 1;
	}
	else
	{
		for (i=0;i<SM_NUM_PARAM_ROWS - 1;i++)
		{
			if (bits > param_table[i][0] && bits <= param_table[i+1][0])
			{
				scale = (double)(param_table[i+1][0] - bits) /
					(double)(param_table[i+1][0] - param_table[i][0]);
				*B = param_table[i+1][1] - 
					(uint32)(scale * (double)(param_table[i+1][1] - param_table[i][1]));
				*M = (uint32)((param_table[i+1][2] + param_table[i][2])/2.0 + 0.5);
				*BL = (uint32)((param_table[i+1][3] + param_table[i][3])/2.0 + 0.5);
			}
		}
	}

	if (*B == 0)
	{
		//off the end of the table, extrapolate based on the slope of 
		//the last two

		scale = (double)(param_table[SM_NUM_PARAM_ROWS-1][1] - param_table[SM_NUM_PARAM_ROWS-2][1]) /
			(double)(param_table[SM_NUM_PARAM_ROWS-1][0] - param_table[SM_NUM_PARAM_ROWS-2][0]);
		*B = (uint32)(((double)bits - param_table[SM_NUM_PARAM_ROWS-1][0]) * 
			scale + param_table[SM_NUM_PARAM_ROWS-1][1]);
		*M = param_table[SM_NUM_PARAM_ROWS-1][2];	//reuse last one

		scale = (double)(param_table[SM_NUM_PARAM_ROWS-1][3] - param_table[SM_NUM_PARAM_ROWS-2][3]) /
			(double)(param_table[SM_NUM_PARAM_ROWS-1][0] - param_table[SM_NUM_PARAM_ROWS-2][0]);
		*BL = (uint32)(((double)bits - param_table[SM_NUM_PARAM_ROWS-1][0]) * 
			scale + param_table[SM_NUM_PARAM_ROWS-1][3]);
	}

	// minimum factor base - for use with really small inputs.
	// not efficient, but needed for decent poly selection
	if (*B < 25)
		*B = 25;

	return;
}


void smallmpqs(fact_obj_t *fobj)
{
	//input expected in fobj->qs_obj.gmp_n
	sm_mpqs_rlist *full, *partial;
	fb_list_sm_mpqs *fb;
	smpqs_sieve_fb *fb_sieve_p,*fb_sieve_n;
	sm_mpqs_poly *poly;
	uint32 *modsqrt;

	mpz_t n;
	mpz_t *factors, tmp, tmp2, tmp3, sqrt_n;
	uint64 *apoly, *bpoly;

	double t_time;
	struct timeval tstart, tend;
	uint32 numpoly, polyalloc;
	uint32 mul,i,j;
	uint32 pmax;							//largest prime in factor base
	uint32 cutoff;
	uint32 sieve_interval;
	uint32 start_prime;
	uint32 num, max_f;
	int digits_n, bits_n, pindex;
	uint32 num_factors;
	uint8 *sieve;							//sieve values
	uint8 s_init;							//initial sieve value
	uint8 closnuf, small_bits;

	//total_locs = 0;
	//td_locs = 0;

	mpz_init(n);
	mpz_init(tmp);
	
	//copy to local variable
	mpz_set(n, fobj->qs_obj.gmp_n);

	if (mpz_cmp_ui(n,1) == 0)
	{
		mpz_clear(n);
		mpz_clear(tmp);
		return;
	}

	if (mpz_even_p(n))
	{
		mpz_clear(n);
		mpz_clear(tmp);
		gmp_printf("%Zu is not odd in smallmpqs\n",n);
		return;
	}

	// size in bits influences mpqs parameters
	bits_n = mpz_sizeinbase(n,2);	

	// don't use the logfile if we see this special flag
	if (fobj->qs_obj.flags != 12345)
	{
		if (fobj->logfile != NULL)
			logprint(fobj->logfile, "starting smallmpqs on C%d: %s\n",
				gmp_base10(n), mpz_conv2str(&gstr1.s, 10, n));

        gettimeofday(&tstart, NULL);
	}

	//empircal tuning of sieve interval based on digits in n
	sm_get_params(bits_n,&j,&sm_sieve_params.large_mult,&sm_sieve_params.num_blocks);

    if (0)
    {
        uint32 prime;
        uint32 small_inv;
        uint32 corr;

        printf("uint32 small_inv_tab[1000][3] = {");
        for (i = 0; i < 1000; i++)
        {            
            prime = spSOEprimes[i];
            if (prime < 256)
            {
                small_inv = (uint32)(((uint64)1 << 32) / (uint64)prime);
                
                if (floor(MP_RADIX / (double)prime + 0.5) ==
                    (double)small_inv) {
                    corr = 1;
                }
                else {
                    corr = 0;
                    small_inv++;
                }
            }
            else
            {
                small_inv = (uint32)(((uint64)1 << 40) / (uint64)prime);
                if (floor(256 * MP_RADIX / (double)prime + 0.5) ==
                    (double)small_inv) {
                    corr = 1;
                }
                else {
                    corr = 0;
                    small_inv++;
                }
            }

            printf("{%u,%u,%u},\n", small_inv, corr, (uint8)(log((double)prime) / log(2.0) + .5));
        }
        printf("}\n");

        exit(1);
    }

    if (0)
    {
        uint32 prime;
        uint32 j;
        uint32 k;
        i = 0;

        printf("uint8 small_sqrt_tab[36][256] = {");
        while (spSOEprimes[i] < 256)
        {
            prime = spSOEprimes[i];
            
            printf("{");
            for (j = 0; j < prime; j++)
            {
                k = 0;
                while (1)
                {
                    if (((k*k) % prime) == j)
                        break;
                    k++;
                }
                if (k > 65536)
                    printf("%u,", 0);
                else
                    printf("%u,", k);
            }
            for (; j<256; j++)
                printf("%u,", 0);

            printf("},\n");
            i++;
        }
        printf("};\n");

        exit(1);
    }
	
	mpz_init(tmp2);
	mpz_init(tmp3);
	
	//default mpqs parameters
	sm_sieve_params.fudge_factor = 1.3;
	if (fobj->qs_obj.gbl_override_lpmult_flag != 0)
		sm_sieve_params.large_mult = fobj->qs_obj.gbl_override_lpmult;

	// how oversquare should we make the matrix?  32 works most of the time;
	// it was observed to not work once, by kar_bon, where the input is comprised
	// of many smallish primes and the matrix is exhaused before they are all found:
	// 1000914215585288002972568692717.  however, calling factor() on this input works
	// fine, and in fact never needs smallmpqs, so this isn't really this routine's
	// fault.  thus it will stay 32...
	sm_sieve_params.num_extra_relations = 32;

	//allocate the space for the factor base
	fb = (fb_list_sm_mpqs *)malloc(sizeof(fb_list_sm_mpqs));
	
	//set fb size from above
	if (fobj->qs_obj.gbl_override_B_flag != 0)
		fb->B = fobj->qs_obj.gbl_override_B;
	else
		fb->B = j;

	if (fobj->qs_obj.gbl_override_blocks_flag != 0)
		sm_sieve_params.num_blocks = fobj->qs_obj.gbl_override_blocks;

	//compute the number of digits in n 
	digits_n = gmp_base10(n);

	//set the sieve interval.  this depends on the size of n, but for now, just fix it.  as more data
	//is gathered, use some sort of table lookup.
	sieve_interval = SM_BLOCKSIZE*sm_sieve_params.num_blocks;

	//allocate the space for the factor base
	modsqrt = (uint32 *)malloc(fb->B * sizeof(uint32));
	fb->list = (fb_element_sm_mpqs *)malloc((size_t)(sizeof(fb_element_sm_mpqs)));
    fb->list->prime = (uint16 *)xmalloc_align(fb->B * sizeof(uint16));
    fb->list->small_inv = (uint32 *)xmalloc_align(fb->B * sizeof(uint32));
    fb->list->logprime = (uint16 *)xmalloc_align(fb->B * sizeof(uint16));
    fb->list->proot1 = (uint16 *)xmalloc_align(fb->B * sizeof(uint16));
    fb->list->proot2 = (uint16 *)xmalloc_align(fb->B * sizeof(uint16));
    fb->list->nroot1 = (uint16 *)xmalloc_align(fb->B * sizeof(uint16));
    fb->list->nroot2 = (uint16 *)xmalloc_align(fb->B * sizeof(uint16));
	fb_sieve_p = (smpqs_sieve_fb *)malloc((size_t)(fb->B * sizeof(smpqs_sieve_fb)));
	fb_sieve_n = (smpqs_sieve_fb *)malloc((size_t)(fb->B * sizeof(smpqs_sieve_fb)));

	//find multiplier
	mul = (uint32)smpqs_choose_multiplier(n,fb->B);
	mpz_mul_ui(n,n,mul);

	//find new sqrt_n
	mpz_init(sqrt_n);
	mpz_sqrt(sqrt_n,n);

	// these values are fixed...
	fb->list->prime[0] = 1;
	fb->list->prime[1] = 2;

	//construct the factor base, and copy to the sieve factor base
	smpqs_make_fb_mpqs(fb,modsqrt,n);

	// small factors can be removed during factor base creation... now is a good
	// time to see how big the number is, and use special methods if it is below 
	// a threshold
	bits_n = mpz_sizeinbase(n,2);	

	if (bits_n > 130)
	{
		printf("******* input too big for smallmpqs *******\n");
		mpz_clear(n);
		mpz_clear(tmp);

		free(fb_sieve_n);
		free(fb_sieve_p);
		align_free(fb->list->logprime);
		align_free(fb->list->small_inv);
		align_free(fb->list->prime);
        align_free(fb->list->proot1);
        align_free(fb->list->proot2);
        align_free(fb->list->nroot1);
        align_free(fb->list->nroot2);
		free(fb->list);
		free(fb);
		return;
	}
    else if ((bits_n < 60) && (fobj->qs_obj.flags != 12345))
	{
		mpz_t ztmp;
		mpz_init(ztmp);

		// squfof and lehman will use their own mulipliers, remove the one we already added
		mpz_tdiv_q_ui(n, n, mul); 
		j = sp_shanks_loop(n, fobj);	

		if (j > 1)
		{
			mpz_set_64(ztmp, j);
			add_to_factor_list(fobj, ztmp);

			if (fobj->qs_obj.flags != 12345)
			{
				if (fobj->logfile != NULL)
					logprint(fobj->logfile,"prp%d = %u\n",ndigits_1(j), j);
			}

			mpz_tdiv_q_ui(n,n,j);
			add_to_factor_list(fobj, n);

			if (fobj->qs_obj.flags != 12345)
			{
				if (fobj->logfile != NULL)
					logprint(fobj->logfile,
						"prp%d = %s\n",gmp_base10(n),mpz_conv2str(&gstr1.s, 10, n));
			}

			mpz_set_ui(fobj->qs_obj.gmp_n, 1);

			free(fb_sieve_n);
			free(fb_sieve_p);
			align_free(fb->list->logprime);
			align_free(fb->list->small_inv);
			align_free(fb->list->prime);
            align_free(fb->list->proot1);
            align_free(fb->list->proot2);
            align_free(fb->list->nroot1);
            align_free(fb->list->nroot2);
			free(fb->list);
			free(fb);
			mpz_clear(n);
			mpz_clear(tmp);
			return;
		}
	}


	// allocate storage for relations based on the factor base size
	max_f = fb->B + 3*sm_sieve_params.num_extra_relations;	
	full = (sm_mpqs_rlist *)malloc((size_t)(sizeof(sm_mpqs_rlist)));
	full->allocated = max_f;
	full->num_r = 0;
	full->act_r = 0;
	full->list = (sm_mpqs_r **)malloc((size_t) (max_f * sizeof(sm_mpqs_r *)));

	// we will typically also generate max_f/2 * 10 partials (empirically determined)
	partial = (sm_mpqs_rlist *)malloc((size_t)(sizeof(sm_mpqs_rlist)));
	partial->allocated = 10*fb->B;
	partial->num_r = 0;
	partial->act_r = 0;
	partial->list = (sm_mpqs_r **)malloc((size_t) (10*fb->B* sizeof(sm_mpqs_r *)));


	for (i=2;i<fb->B;i++)
	{
		fb_sieve_p[i].prime_and_logp = (fb->list->prime[i] << 16) | (fb->list->logprime[i]);
		fb_sieve_n[i].prime_and_logp = (fb->list->prime[i] << 16) | (fb->list->logprime[i]);
	}

	// allocate the sieve
	sieve = (uint8 *)xmalloc_align(SM_BLOCKSIZE * sizeof(uint8));

	// allocate the current polynomial
	poly = (sm_mpqs_poly *)malloc(sizeof(sm_mpqs_poly));
	mpz_init(poly->poly_c);

	// allocate the polynomial lists
	polyalloc = 32;
	apoly = (uint64 *)malloc(polyalloc * sizeof(uint64));
	bpoly = (uint64 *)malloc(polyalloc * sizeof(uint64));

	// find upper bound of Q values
	mpz_tdiv_q_2exp(tmp,n,1);
	mpz_sqrt(tmp2,tmp);
	mpz_mul_ui(tmp, tmp2, sieve_interval);
	
	// compute the first polynominal 'a' value.  we'll need it before creating the factor base in order
	// to find the first roots
	// 'a' values should be as close as possible to sqrt(2n)/M, they should be a quadratic residue mod N (d/N) = 1,
	// and be a prime congruent to 3 mod 4.  this last requirement is so that b values can be computed without using the 
	// shanks-tonelli algorithm, and instead use faster methods.
	// since a = d^2, find a d value near to sqrt(sqrt(2n)/M)
	mpz_mul_2exp(tmp, n, 1);
	mpz_sqrt(tmp2, tmp);
	mpz_tdiv_q_ui(tmp2, tmp2, sieve_interval);

	mpz_sqrt(tmp, tmp2);
	if (mpz_even_p(tmp))
		mpz_add_ui(tmp, tmp, 1);
	
	mpz_nextprime(tmp, tmp);
	poly->poly_d = (uint64)mpz_get_ui(tmp);

	if (spSOEprimes[szSOEp - 1] <= poly->poly_d)
		smpqs_get_more_primes(poly);

	pindex = bin_search_uint32(szSOEp, 0, poly->poly_d, spSOEprimes);
	if (pindex < 0)
	{
		printf("prime not found in binary search\n");
		exit(1);
	}
	poly->poly_d_idp = pindex;
	poly->poly_d_idn = pindex;
	poly->side = 1;
	poly->use_only_p = 0;

	smpqs_nextD(poly,n);
	smpqs_computeB(poly,n);	

	// find the root locations of the factor base primes for this poly
	smpqs_computeRoots(poly,fb,modsqrt,fb_sieve_p,fb_sieve_n,2);

	pmax = fb->list->prime[fb->B-1];
	cutoff = pmax * sm_sieve_params.large_mult;

	// compute the number of bits in M/2*sqrt(N/2), the approximate value
	// of residues in the sieve interval
	// sieve locations greater than this are worthy of trial dividing
	closnuf = (uint8)(double)((bits_n - 1)/2);
	closnuf += (uint8)(log((double)sieve_interval/2)/log(2.0));
	closnuf -= (uint8)(sm_sieve_params.fudge_factor * log(cutoff) / log(2.0));
	
	closnuf += 6;

	// small prime variation -- hand tuned small_bits correction (likely could be better)
	small_bits = 7;
	closnuf -= small_bits;
	start_prime = 7;
	
	s_init = closnuf;

	// print some info to the screen and the log file
	if (VFLAG > 0)
	{
		gmp_printf("n = %Zd (%d digits and %d bits)\n",n,digits_n,bits_n);
		printf("==== sieve params ====\n");
		printf("factor base: %d primes (max prime = %u)\n",fb->B,pmax);
		printf("large prime cutoff: %u (%d * pmax)\n",cutoff,sm_sieve_params.large_mult);
		printf("sieve interval: %d blocks of size %d\n",sieve_interval/SM_BLOCKSIZE,SM_BLOCKSIZE);
		printf("multiplier is %u\n",mul);
		printf("trial factoring cutoff at %d bits\n",closnuf);
		printf("==== sieving in progress ====\n");
	}

	numpoly = 0;
	num = 0;

	// arbitrary upper bound of polys to try.  if more than this, somethings wrong.
	while (numpoly < 2048)
	{		
		//copy current poly into the poly lists
		if (numpoly < polyalloc)
		{
			apoly[numpoly] = poly->poly_a;
			bpoly[numpoly] = poly->poly_b;
		}
		else
		{
			// get more space for the polys, if needed
			polyalloc *= 2;
			apoly = (uint64 *)realloc(apoly, polyalloc * sizeof(uint64));
			bpoly = (uint64 *)realloc(bpoly, polyalloc * sizeof(uint64));

			apoly[numpoly] = poly->poly_a;
			bpoly[numpoly] = poly->poly_b;
		}

        // sieve one block only
		smpqs_sieve_block(sieve,fb_sieve_p,start_prime,s_init,fb);

		i = smpqs_check_relations(sieve_interval,0,sieve,n,poly,
			s_init,fb_sieve_p,fb,full,partial,cutoff,small_bits,
			start_prime,0,&num,numpoly);

		smpqs_sieve_block(sieve,fb_sieve_n,start_prime,s_init,fb);
		
		i = smpqs_check_relations(sieve_interval,0,sieve,n,poly,
			s_init,fb_sieve_n,fb,full,partial,cutoff,small_bits,
			start_prime,1,&num,numpoly);
		
		if (VFLAG > 1)
			printf("%d rels found: %d full + "
				"%d from %d partial, (%d total polys)\r",
				partial->act_r + full->num_r,
				full->num_r, partial->act_r, partial->num_r, numpoly);

		if (partial->num_r > 0)
		{
			//check the partials for full relations
			qsort(partial->list,partial->num_r,sizeof(sm_mpqs_r *),&qcomp_smpqs);
			j=0;
			for (i=0;i<partial->num_r-1;i++)
			{
				if (partial->list[i]->largeprime == partial->list[i+1]->largeprime)
					j++;
			}
			partial->act_r = j;
				
			if (j+(full->num_r) >= fb->B + sm_sieve_params.num_extra_relations) 
			{
				//we've got enough total relations to stop
				goto done;
			}
		}

		//next polynomial
		smpqs_nextD(poly,n);
		smpqs_computeB(poly,n);
		smpqs_computeRoots(poly,fb,modsqrt,fb_sieve_p,fb_sieve_n,start_prime);

		numpoly++;
	}	

done:

	if (VFLAG > 0)
		printf("%d relations found: %d full + %d from %d partial, using %d polys\n",
			partial->act_r+full->num_r,full->num_r,partial->act_r,partial->num_r,numpoly);

	gettimeofday (&tend, NULL);
    t_time = my_difftime(&tstart, &tend);

	if (VFLAG > 0)
		printf("QS elapsed time = %6.4f seconds.\n",t_time);

	//printf("%" PRIu64 " blocks scanned, %" PRIu64 " hit\n",total_locs, td_locs);

	//can free sieving structures now
	align_free(sieve);
	free(fb_sieve_p);
	free(fb_sieve_n);
	mpz_clear(poly->poly_c);
	free(poly);
	free(modsqrt);

	if (numpoly >= 2048)
	{
		// something went wrong.
		// example, wraithx's 151116012007860377
		// see: http://www.mersenneforum.org/showpost.php?p=369993&postcount=273
		//
		// assume this is rare and just do rho until it factors...
		uint32 tmpi = fobj->rho_obj.iterations;
		mpz_set(fobj->rho_obj.gmp_n, fobj->qs_obj.gmp_n);

		logprint(fobj->logfile, "Smallmpqs failed: bruteforcing with rho\n");
		while (mpz_cmp_ui(fobj->rho_obj.gmp_n, 1) > 0)
		{
			fobj->rho_obj.iterations *= 2;
			brent_loop(fobj);
		}
		
		fobj->rho_obj.iterations = tmpi;
		mpz_set_ui(fobj->qs_obj.gmp_n, 1);
	}
	else
	{
		num_factors=0;
		factors = (mpz_t *)malloc(MAX_FACTORS * sizeof(mpz_t));
		for (i=0;i<MAX_FACTORS;i++)
			mpz_init(factors[i]);

		gettimeofday(&tstart,NULL);
		i = smpqs_BlockGauss(full,partial,apoly,bpoly,fb,n,mul,
			factors,&num_factors);

		gettimeofday (&tend, NULL);
        t_time = my_difftime(&tstart, &tend);
	
		if (VFLAG > 0)
			printf("Gauss elapsed time = %6.4f seconds.\n",t_time);

		for(i=0;i<num_factors;i++)
		{
			add_to_factor_list(fobj, factors[i]);

			if (fobj->qs_obj.flags != 12345)
			{
				if (fobj->logfile != NULL)
					logprint(fobj->logfile,
						"prp%d = %s\n", gmp_base10(factors[i]),
						mpz_conv2str(&gstr1.s, 10, factors[i]));
			}
		
			mpz_tdiv_q(fobj->qs_obj.gmp_n, fobj->qs_obj.gmp_n, factors[i]);
		}

		for (i=0;i<MAX_FACTORS;i++)
			mpz_clear(factors[i]);
		free(factors);
	}
		
	

	mpz_clear(n);
	mpz_clear(tmp);
	mpz_clear(tmp2);
	mpz_clear(tmp3);
	mpz_clear(sqrt_n);

	for (i=0;i<full->num_r;i++)
	{
		free(full->list[i]->fboffset);
		free(full->list[i]);
	}
	free(full->list);
	free(full);

	for (i=0;i<partial->num_r;i++)
	{
		free(partial->list[i]->fboffset);
		free(partial->list[i]);
	}
	free(partial->list);
	free(partial);

	free(apoly);
	free(bpoly);

	align_free(fb->list->prime);
	align_free(fb->list->logprime);
	align_free(fb->list->small_inv);
    align_free(fb->list->proot1);
    align_free(fb->list->proot2);
    align_free(fb->list->nroot1);
    align_free(fb->list->nroot2);
	free(fb->list);
	free(fb);

	return;
}

void smpqs_get_more_primes(sm_mpqs_poly *poly)
{
	uint64 num_p;
	int i;

	if (VFLAG > 1)
		printf("smallmpqs getting more primes: poly_d = %u\n",
		poly->poly_d);

	PRIMES = GetPRIMESRange(spSOEprimes, szSOEp, NULL, 0, 
		(uint64)((double)poly->poly_d * 1.25), &num_p);

	//save a batch of sieve primes too.
	spSOEprimes = (uint32 *)realloc(spSOEprimes, 
		(size_t) (num_p * sizeof(uint32)));

	for (i=0;i<num_p;i++)
		spSOEprimes[i] = (uint32)PRIMES[i];

	szSOEp = num_p;
	NUM_P = num_p;
	P_MIN = 0; 
	P_MAX = PRIMES[(uint32)NUM_P-1];

	if (VFLAG > 1)
		printf("prime finding complete, cached %u primes. pmax = %u\n",
		(uint32)NUM_P, (uint32)P_MAX);

	return;
}

static uint8 smpqs_mult_list[] =
	{1, 2, 3, 5, 7, 10, 11, 13, 15, 17, 19, 
	 23, 26, 29, 30, 31, 43, 59, 67, 73};

uint8 smpqs_choose_multiplier(mpz_t n, uint32 fb_size) 
{
	uint32 i, j;
	uint32 num_primes = MIN(2 * fb_size, 30);
	double best_score;
	uint8 best_mult;
	double scores[20];
	uint32 num_multipliers;
	mpz_t tmp;

	mpz_init(tmp);

	/* measure the contribution of 2 as a factor of sieve
	   values. The multiplier itself must also be taken into
	   account in the score. scores[i] is the correction that
	   is implicitly applied to the size of sieve values for
	   multiplier i; a negative score makes sieve values 
	   smaller, and so is better */

	for (i = 0; i < 20; i++) {
		uint8 curr_mult = smpqs_mult_list[i];
		uint8 knmod8 = (uint8)((curr_mult * mpz_get_ui(n)) % 8);
		double logmult = log((double)curr_mult);

		scores[i] = 0.5 * logmult;
		switch (knmod8) {
		case 1:
			scores[i] -= 2 * LN2;
			break;
		case 5:
			scores[i] -= LN2;
			break;
		case 3:
		case 7:
			scores[i] -= 0.5 * LN2;
			break;
		/* even multipliers start with a handicap */
		}
	}
	num_multipliers = i;

	/* for the rest of the small factor base primes */
	for (i = 1; i < num_primes; i++) {
		uint32 prime = (uint32)spSOEprimes[i];
		double contrib = log((double)prime) / (prime - 1);
		uint32 modp = (uint32)mpz_tdiv_ui(n,prime);

		for (j = 0; j < num_multipliers; j++) {
			uint8 curr_mult = smpqs_mult_list[j];
			uint32 knmodp = (modp * curr_mult) % prime;

			mpz_set_ui(tmp, knmodp);

			/* if prime i is actually in the factor base
			   for k * n ... */

			if (knmodp == 0 || mpz_kronecker_ui(tmp, prime) == 1) { //jacobi_1(knmodp, prime) == 1) {

				/* ...add its contribution. A prime p con-
				   tributes log(p) to 1 in p sieve values, plus
				   log(p) to 1 in p^2 sieve values, etc. The
				   average contribution of all multiples of p 
				   to a random sieve value is thus

				   log(p) * (1/p + 1/p^2 + 1/p^3 + ...)
				   = (log(p) / p) * 1 / (1 - (1/p)) 
				   = log(p) / (p-1)

				   This contribution occurs once for each
				   square root used for sieving. There are two
				   roots for each factor base prime, unless
				   the prime divides k*n. In that case there 
				   is only one root */

				//printf("scores[%d] = %f\n",j,contrib);
				if (knmodp == 0)
					scores[j] -= contrib;
				else
					scores[j] -= 2 * contrib;
			}
		}

	}

	/* use the multiplier that generates the best score */
	best_score = 1000.0;
	best_mult = 1;
	for (i = 0; i < num_multipliers; i++) {
		
		double score = scores[i];
		if (score < best_score) {
			best_score = score;
			best_mult = smpqs_mult_list[i];
		}
	}

	mpz_clear(tmp);
	return best_mult;
}

int smpqs_check_relations(uint32 sieve_interval, uint32 blocknum, uint8 *sieve, mpz_t n, sm_mpqs_poly *poly, uint8 closnuf,
						smpqs_sieve_fb *fb,fb_list_sm_mpqs *fullfb, sm_mpqs_rlist *full, sm_mpqs_rlist *partial, 
						uint32 cutoff, uint8 small_cutoff, uint32 start_prime, uint32 parity, uint32 *num, int numpoly)
{
	mpz_t Q,t1,t2,t3;
	uint32 offset,i,j;
	uint32 neg;
	uint64 *sieveblock;
	uint32 limit = SM_BLOCKSIZE >> 3;
		
	sieveblock = (uint64 *)sieve;
	mpz_init(Q);
	mpz_init(t1);
	mpz_init(t2);
	mpz_init(t3);

#if defined(SM_SIMD_SIEVE_SCAN_VEC)

	for (j=0;j<limit;j+=8)	
	{		
		uint32 result;
		uint8 buffer[64];
		
		SM_SIEVE_SCAN_64_VEC;

		if (result == 0)
			continue;
		
		for (i=0; i<result; i++)
		{
			uint32 thisloc = (j << 3) + (uint32)buffer[i];

			(*num)++;

			offset = (blocknum<<15) + thisloc;
			mpz_set_64(t2, poly->poly_b);
			mpz_mul_2exp(t2, t2, 1);

			mpz_set_64(t1, poly->poly_a);
			mpz_mul_ui(t1, t1, offset);
			if (parity)
				mpz_sub(t3, t1, t2);
			else
				mpz_add(t3, t1, t2);

			mpz_mul_ui(t1, t3, offset);
			mpz_add(Q, t1, poly->poly_c);
			if (mpz_sgn(Q) < 0)
			{
				neg = 1;
				mpz_neg(Q, Q);
			}
			else
				neg = 0;
				
			smpqs_trial_divide_Q(Q,fb,full,partial,sieve,offset,
				thisloc,neg,fullfb,cutoff,small_cutoff,start_prime,
				numpoly,parity,closnuf,sieve[thisloc]);
		}
	}

	SM_SCAN_CLEAN;

#elif defined(SM_SIMD_SIEVE_SCAN)

	for (j=0;j<limit;j+=8)	
	{
		uint32 result, k;

		SM_SIEVE_SCAN_64;

		if (result == 0)
			continue;

		for (i=0; i<8; i++)
		{
			//check 8 locations simultaneously
			if ((sieveblock[j + i] & SM_SCAN_MASK) == (uint64)(0))
				continue;

			//at least one passed the check, find which one(s) and pass to 
			//trial division stage
			for (k=0;k<8;k++)
			{
				uint32 thisloc = ((j+i)<<3) + k;
				if ((sieve[thisloc] & 0x80) == 0)
					continue;

				(*num)++;

				offset = (blocknum<<15) + thisloc;
				mpz_set_64(t2, poly->poly_b);
				mpz_mul_2exp(t2, t2, 1);

				mpz_set_64(t1, poly->poly_a);
				mpz_mul_ui(t1, t1, offset);
				if (parity)
					mpz_sub(t3, t1, t2);
				else
					mpz_add(t3, t1, t2);

				mpz_mul_ui(t1, t3, offset);
				mpz_add(Q, t1, poly->poly_c);
				if (mpz_sgn(Q) < 0)
				{
					neg = 1;
					mpz_neg(Q, Q);
				}
				else
					neg = 0;

				smpqs_trial_divide_Q(Q,fb,full,partial,sieve,offset,
					thisloc,neg,fullfb,cutoff,small_cutoff,start_prime,
					numpoly,parity,closnuf,sieve[thisloc]);
			}
		}
	}

	SM_SCAN_CLEAN;

#else


	for (j=0;j<limit;j+=8)	
	{
		uint32 k;

		if (((sieveblock[j] | sieveblock[j+1] | sieveblock[j+2] | sieveblock[j+3] |
		      sieveblock[j+4] | sieveblock[j+5] | sieveblock[j+6] | sieveblock[j+7]
			) & SM_SCAN_MASK) == (uint64)(0))
			continue;

		for (i=0; i<8; i++)
		{
			//check 8 locations simultaneously
			if ((sieveblock[j + i] & SM_SCAN_MASK) == (uint64)(0))
				continue;

			//at least one passed the check, find which one(s) and pass to 
			//trial division stage
			for (k=0;k<8;k++)
			{
				uint32 thisloc = ((j+i)<<3) + k;
				if ((sieve[thisloc] & 0x80) == 0)
					continue;

				(*num)++;

				offset = (blocknum<<15) + thisloc;
				mpz_set_64(t2, poly->poly_b);
				mpz_mul_2exp(t2, t2, 1);

				mpz_set_64(t1, poly->poly_a);
				mpz_mul_ui(t1, t1, offset);
				if (parity)
					mpz_sub(t3, t1, t2);
				else
					mpz_add(t3, t1, t2);

				mpz_mul_ui(t1, t3, offset);
				mpz_add(Q, t1, poly->poly_c);
				if (mpz_sgn(Q) < 0)
				{
					neg = 1;
					mpz_neg(Q, Q);
				}
				else
					neg = 0;

				smpqs_trial_divide_Q(Q,fb,full,partial,sieve,offset,
					thisloc,neg,fullfb,cutoff,small_cutoff,start_prime,
					numpoly,parity,closnuf,sieve[thisloc]);
			}
		}
	}

#endif

	mpz_clear(Q);
	mpz_clear(t1);
	mpz_clear(t2);
	mpz_clear(t3);
	return full->num_r;
}

#define DIVIDE_ONE_PRIME \
	while (mpz_tdiv_ui(Q, prime) == 0) \
	{						\
		fboffset[++smooth_num] = i;	\
		mpz_tdiv_q_ui(Q, Q, prime); 	\
	}

void smpqs_trial_divide_Q(mpz_t Q, smpqs_sieve_fb *fb, sm_mpqs_rlist *full, sm_mpqs_rlist *partial,
						  uint8 *sieve, uint32 offset, uint32 j, uint32 sign, fb_list_sm_mpqs *fullfb, uint32 cutoff,
						  uint8 small_cutoff, uint32 start_prime, int numpoly, uint32 parity,uint8 closnuf,uint8 bits)
{
	smpqs_sieve_fb *fbptr;
	uint32 i,num_f,num_p;
	uint32 root1,root2,prime;
	int smooth_num;
	uint16 fboffset[SM_MAX_SMOOTH_PRIMES];
	uint8 logp;

	num_f = full->num_r;
	num_p = partial->num_r;
	
	// we have two signs to worry about.  the sign of the offset tells us how to calculate ax + b, while
	// the sign of Q(x) tells us how to factor Q(x) (with or without a factor of -1)
	// the square root phase will need to know both.  fboffset holds the sign of Q(x).  the sign of the 
	// offset is stored standalone in the relation structure.
	if (sign)
		fboffset[0] = 1;
	else
		fboffset[0] = 0;

	smooth_num=0;
	bits = (255-sieve[j]) + closnuf + 1;

	// take care of powers of two
	while (mpz_even_p(Q))
	{
		mpz_tdiv_q_2exp(Q,Q,1);
		fboffset[++smooth_num] = 1;
	}

	// completely unrolled trial division by primes that we have not 
	// sieved via the small prime variation
	{
		uint32 tmp1;

		fbptr = fb + 2;
		root1 = fbptr->roots >> 16;	
		root2 = fbptr->roots & 0xffff;

		prime = fbptr->prime_and_logp >> 16;
		logp = fbptr->prime_and_logp & 0xff;

        tmp1 = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[2]) >> 32);
        tmp1 = offset - tmp1 * prime;
        if (tmp1 >= prime) tmp1 -= prime;

		if (tmp1 == root1 || tmp1 == root2)
		{
			do
			{
				fboffset[++smooth_num] = 2;
				mpz_tdiv_q_ui(Q,Q,prime);
				bits += logp;
			} while (mpz_tdiv_ui(Q,prime) == 0);
		}

		fbptr = fb + 3;
		root1 = fbptr->roots >> 16;	
		root2 = fbptr->roots & 0xffff;

		prime = fbptr->prime_and_logp >> 16;
		logp = fbptr->prime_and_logp & 0xff;

        tmp1 = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[3]) >> 32);
        tmp1 = offset - tmp1 * prime;
        if (tmp1 >= prime) tmp1 -= prime;

		if (tmp1 == root1 || tmp1 == root2)
		{
			do
			{
				fboffset[++smooth_num] = 3;
				mpz_tdiv_q_ui(Q,Q,prime);
				bits += logp;
			} while (mpz_tdiv_ui(Q,prime) == 0);
		}

		fbptr = fb + 4;
		root1 = fbptr->roots >> 16;	
		root2 = fbptr->roots & 0xffff;

		prime = fbptr->prime_and_logp >> 16;
		logp = fbptr->prime_and_logp & 0xff;

        tmp1 = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[4]) >> 32);
        tmp1 = offset - tmp1 * prime;
        if (tmp1 >= prime) tmp1 -= prime;

		if (tmp1 == root1 || tmp1 == root2)
		{
			do
			{
				fboffset[++smooth_num] = 4;
				mpz_tdiv_q_ui(Q,Q,prime);
				bits += logp;
			} while (mpz_tdiv_ui(Q,prime) == 0);
		}

		fbptr = fb + 5;
		root1 = fbptr->roots >> 16;	
		root2 = fbptr->roots & 0xffff;

		prime = fbptr->prime_and_logp >> 16;
		logp = fbptr->prime_and_logp & 0xff;

        tmp1 = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[5]) >> 32);
        tmp1 = offset - tmp1 * prime;
        if (tmp1 >= prime) tmp1 -= prime;

		if (tmp1 == root1 || tmp1 == root2)
		{
			do
			{
				fboffset[++smooth_num] = 5;
				mpz_tdiv_q_ui(Q,Q,prime);
				bits += logp;
			} while (mpz_tdiv_ui(Q,prime) == 0);
		}

		fbptr = fb + 6;
		root1 = fbptr->roots >> 16;	
		root2 = fbptr->roots & 0xffff;

		prime = fbptr->prime_and_logp >> 16;
		logp = fbptr->prime_and_logp & 0xff;

        tmp1 = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[6]) >> 32);
        tmp1 = offset - tmp1 * prime;
        if (tmp1 >= prime) tmp1 -= prime;

		if (tmp1 == root1 || tmp1 == root2)
		{
			do
			{
				fboffset[++smooth_num] = 6;
				mpz_tdiv_q_ui(Q,Q,prime);
				bits += logp;
			} while (mpz_tdiv_ui(Q,prime) == 0);
		}
	}

	if (bits < (closnuf + small_cutoff))
		return;

	i=start_prime;
	while (i < fullfb->B)
	{
		uint32 tmp;

		fbptr = fb + i;
		root1 = (fbptr->roots >> 16); // + SM_BLOCKSIZE - j;	
		root2 = (fbptr->roots & 0xffff); // + SM_BLOCKSIZE - j;
		prime = fbptr->prime_and_logp >> 16;

		if (prime > 256)
			break;
		
        tmp = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[i]) >> 32);
        tmp = offset - tmp * prime;
        if (tmp >= prime) tmp -= prime;

		if (tmp == root1 || tmp == root2)
			DIVIDE_ONE_PRIME;			

		i++;
	}

	while (i < fullfb->B)
	{
		uint32 tmp;

		fbptr = fb + i;
		root1 = (fbptr->roots >> 16); // + SM_BLOCKSIZE - j;		
		root2 = (fbptr->roots & 0xffff); // + SM_BLOCKSIZE - j;
		prime = fbptr->prime_and_logp >> 16;

        tmp = (uint32)(((uint64)offset * (uint64)fullfb->list->small_inv[i]) >> 40);
        tmp = offset - tmp * prime;
        if (tmp >= prime) tmp -= prime;

		if (tmp == root1 || tmp == root2)
			DIVIDE_ONE_PRIME;		

		i++;
	}

	//check if it completely factored by looking at the unfactored portion in tmp
	if (mpz_cmp_ui(Q,1) == 0)
	{
		if (full->num_r == full->allocated) 
		{
			full->allocated *= 2;
			full->list = (sm_mpqs_r **)realloc(full->list, 
					full->allocated * sizeof(sm_mpqs_r *));
		}
		smpqs_save_relation(full,offset,1,smooth_num+1,num_f,fboffset,numpoly,parity);
	}
	else if (mpz_cmp_ui(Q,cutoff) < 0)
	{
		smpqs_save_relation(partial,offset,mpz_get_ui(Q),smooth_num+1,num_p,fboffset,numpoly,parity);

		if (partial->num_r == partial->allocated) 
		{
			partial->allocated *= 2;
			partial->list = (sm_mpqs_r **)realloc(partial->list, 
					partial->allocated * sizeof(sm_mpqs_r *));
		}
	}

	return;
}

void smpqs_save_relation(sm_mpqs_rlist *list, uint32 offset, uint32 largeprime, uint32 num_factors, 
						  uint32 rnum, uint16 *fboffset, int numpoly, uint32 parity)
{
	uint32 i;
	list->list[rnum] = (sm_mpqs_r *)malloc(sizeof(sm_mpqs_r));
	list->list[rnum]->fboffset = (uint16 *)malloc(num_factors*sizeof(uint16));
	for (i=0;i<num_factors;i++)
		list->list[rnum]->fboffset[i] = fboffset[i];
	
	list->list[rnum]->offset = offset;
	list->list[rnum]->largeprime = largeprime;
	list->list[rnum]->parity = parity;
	list->list[rnum]->num_factors = (uint8)(num_factors);
	list->list[rnum]->polynum = numpoly;
	list->num_r++;
	return;
}

void smpqs_sieve_block(uint8 *sieve, smpqs_sieve_fb *fb, uint32 start_prime, 
	uint8 s_init, fb_list_sm_mpqs *fullfb)
{
	uint32 prime, root1, root2, stop;
	uint32 B=fullfb->B;
	uint32 i, fourp;
	uint8 logp, *s2, *s3, *s4;
	smpqs_sieve_fb *fbptr;

	//initialize block
	memset(sieve,s_init,SM_BLOCKSIZE);
	
	//we've now filled the entire block with the small fb primes, proceed with the rest
	for (i=start_prime;i<B;i++)
	{	
		fbptr = fb + i;
		prime = fbptr->prime_and_logp >> 16;
		root1 = fbptr->roots >> 16;
		root2 = fbptr->roots & 0xffff;
		logp = fbptr->prime_and_logp & 0xff;

		fourp = prime << 2;
		stop = SM_BLOCKSIZE - fourp + prime; //stop = SM_BLOCKSIZE - prime;
		s2 = sieve + prime;
		s3 = s2 + prime;
		s4 = s3 + prime;

		while (root2 < stop)
		{
			sieve[root1] -= logp;
			sieve[root2] -= logp;
			s2[root1] -= logp;
			s2[root2] -= logp;
			s3[root1] -= logp;
			s3[root2] -= logp;
			s4[root1] -= logp;
			s4[root2] -= logp;
			root1 += fourp;
			root2 += fourp;
		}

		while (root2 < SM_BLOCKSIZE)
		{
			sieve[root1] -= logp;
			sieve[root2] -= logp;
			root1 += prime;
			root2 += prime;
		}

	}

	return;
}

void smpqs_nextD(sm_mpqs_poly *poly, mpz_t n)
{
	uint32 r;

	if (poly->side || poly->use_only_p)
	{
		do 
		{
			poly->poly_d_idp++;
			if (poly->poly_d_idp >= szSOEp)
				smpqs_get_more_primes(poly);
			poly->poly_d = spSOEprimes[poly->poly_d_idp];
			r = mpz_tdiv_ui(n,poly->poly_d);
		} while ((jacobi_1(r,poly->poly_d) != 1) || ((poly->poly_d & 3) != 3));
	}
	else
	{
		do 
		{
			poly->poly_d_idn--;
			if (poly->poly_d_idn < 5)
			{
				poly->use_only_p = 1;
				smpqs_nextD(poly, n);
				return;
			}
			poly->poly_d = spSOEprimes[poly->poly_d_idn];			
			r = mpz_tdiv_ui(n,poly->poly_d);
		} while ((jacobi_1(r,poly->poly_d) != 1) || ((poly->poly_d & 3) != 3));
	}

	poly->side = !poly->side;

	return;
}

void spModExp_1(uint32 a, uint32 b, uint32 m, uint32 *u)
{
#ifdef TESTING
    mpz_t res, x, n;
    mpz_init(res);
    mpz_init(x);
    mpz_init(n);
    mpz_set_ui(x, a);
    mpz_set_ui(n, m);
    mpz_powm_ui(res, x, b, n);
    *u = mpz_get_ui(res);
    mpz_clear(res);
    mpz_clear(x);
    mpz_clear(n);

#else
    // computes a^b mod m = u using the binary method
    // see, for instance, the handbook of applied cryptography
    uint32 aa, t, nhat;
    uint32 n, bb;

    t = (((m + 2) & 4) << 1) + m; // here x*a==1 mod 2**4
    t *= 2 - m * t;               // here x*a==1 mod 2**8
    t *= 2 - m * t;               // here x*a==1 mod 2**16
    t *= 2 - m * t;               // here x*a==1 mod 2**32         
    nhat = (uint32)0 - t;

    n = u32div(1, m);
    aa = u32div(a, m);
    bb = b;
    while (bb != 0)
    {
        if (bb & 0x1)
        {
            n = mulredc32(n, aa, m, nhat);
        }
        bb >>= 1;
        aa = mulredc32(aa, aa, m, nhat);
    }
    *u = mulredc32(1, n, m, nhat);

#endif

    return;
}

void smpqs_computeB(sm_mpqs_poly *poly, mpz_t n)
{
	//using poly_d, compute poly_b and poly_a = poly_d^2
    mpz_t t2;
    uint64 u64a;
	uint32 ut1, ut2, ut3;
    uint32 nmodd;
	uint32 polyd = poly->poly_d;

	mpz_init(t2);
	//poly_a = d^2.  we just found d.  also compute b using Hegel theorem and lifting.

	// t0 = n^(d-3)/4 mod d
    nmodd = mpz_tdiv_ui(n, polyd);
    spModExp_1(nmodd, (polyd - 3) >> 2, polyd, &ut1);

	// h1 = n*t0 mod d
    ut2 = (uint64)ut1 * (uint64)nmodd % (uint64)polyd;

	// n - h1^2
    mpz_set_ui(t2, ut2);
    mpz_mul(t2, t2, t2);
    mpz_sub(t2, n, t2);

    //gmp_printf("n = %Zd, ut1 = %lu, ut2 = %lu, nmodd = %lu, t2 = %Zd\n", n, ut1, ut2, nmodd, t2);

	// (n - h1^2)/d
	mpz_tdiv_q_ui(t2, t2, polyd);

	// (n - h1^2)/d mod d
    ut3 = mpz_tdiv_ui(t2, polyd);

	// compute t6 = (2*h1)^-1 mod d = (2*h1)^(d-2) mod d
    ut1 = ((uint64)ut2 * 2ULL) % (uint64)polyd;
    ut1 = modinv_1(ut1, polyd);

	// compute h2 = ((2*h1)^-1 * (n - h1^2)/d) mod d
    ut3 = (uint64)ut3 * (uint64)ut1 % (uint64)polyd;

	// compute t5 = h1 + h2*D
    u64a = (uint64)ut3 * (uint64)polyd + (uint64)ut2;

    //gmp_printf("ut1 = %lu, ut3 = %lu, u64a = %llu, t2 = %Zd\n", ut1, ut3, u64a, t2);

	// we're now done with d, so compute a = d^2
	poly->poly_a = (uint64)polyd * (uint64)polyd;

	// compute b = h1 + h2*d mod a
    poly->poly_b = u64a % poly->poly_a;

	// make sure b < a/2
	if (poly->poly_b > (poly->poly_a >> 1))
		poly->poly_b = poly->poly_a - poly->poly_b;

	// now that we have b, compute c = (b*b - n)/a
	mpz_set_64(t2, poly->poly_b);
	mpz_mul(t2, t2, t2);
	mpz_sub(t2, t2, n); 

    mpz_set_64(poly->poly_c, poly->poly_a);
    mpz_tdiv_q(poly->poly_c, t2, poly->poly_c);
    // MINGW64 bug?  below doesn't work for mingw64 but does for 64-bit gcc/intel/msvc
    //mpz_tdiv_q_ui(poly->poly_c, t2, poly->poly_a);

    //gmp_printf("d = %u, a = %llu, b = %llu, c = %Zd\n", 
    //    poly->poly_d, poly->poly_a, poly->poly_b, poly->poly_c);

	mpz_clear(t2);
	return;
}

int sm_check_relation(mpz_t a, mpz_t b, sm_mpqs_r *r, fb_list_sm_mpqs *fb, mpz_t n)
{
	int offset, lp, parity, num_factors;
	int j,retval;
	mpz_t Q, RHS,t1,t2;

	mpz_init(Q);
	mpz_init(RHS);
	mpz_init(t1);
	mpz_init(t2);

	offset = r->offset;
	lp = r->largeprime;
	parity = r->parity;
	num_factors = r->num_factors;

	mpz_set_ui(RHS, lp);
	for (j=1; j<num_factors; j++)
		mpz_mul_ui(RHS, RHS, fb->list->prime[r->fboffset[j]]);

	//Q(x)/a = (ax + b)^2 - N, where x is the sieve index
	mpz_mul_ui(t1, a, offset);
	if (parity)
		mpz_sub(t2, t1, b);
	else
		mpz_add(t2, t1, b);
	mpz_mul(t1, t2, t2);
	mpz_sub(Q, t1, n);
	mpz_tdiv_q(Q, Q, a);

	retval = 0;
	if (mpz_sgn(Q) < 0)
	{
		mpz_neg(Q,Q);
	}

	if (mpz_cmp(Q,RHS) != 0)
	{
		printf("failure to equate relation\n");
		gmp_printf("%Zd %Zd\n",Q,RHS);
		retval = 1;
	}

	mpz_clear(Q);
	mpz_clear(RHS);
	mpz_clear(t1);
	mpz_clear(t2);
	return retval;
}

void smpqs_computeRoots(sm_mpqs_poly *poly, fb_list_sm_mpqs *fb, uint32 *modsqrt, 
	smpqs_sieve_fb *fbp, smpqs_sieve_fb *fbn, uint32 start_prime)
{
	//the roots are computed using a and b as follows:
	//(+/-t - b)(a)^-1 mod p
	//assume b > t
	//uint32 root1, root2, prime, amodp;
	int root1, root2, prime, amodp, bmodp, x;
	uint32 i;
	
	for (i=2;i<start_prime;i++)
	{
		uint64 tmp, t2;

		prime = fb->list->prime[i]; 
		root1 = modsqrt[i]; 
		root2 = prime - root1; 

		bmodp = poly->poly_b % (uint64)prime;
		x = (int)root1 - bmodp;
		if (x < 0) x += prime; 
        root1 = x;
		x = (int)root2 - bmodp;
		if (x < 0) x += prime; 
        root2 = x;

		amodp = poly->poly_a % (uint64)prime;
		amodp = modinv_1(amodp,prime);

		t2 = (uint64)amodp * (uint64)root1;
        tmp = (((uint64)t2 * (uint64)fb->list->small_inv[i]) >> 32);
		root1 = t2 - tmp * prime;
        if (root1 >= prime) root1 -= prime;

		t2 = (uint64)amodp * (uint64)root2;
        tmp = (((uint64)t2 * (uint64)fb->list->small_inv[i]) >> 32);
		root2 = t2 - tmp * prime;
        if (root2 >= prime) root2 -= prime;

		// we don't sieve these primes, so ordering doesn't matter
		fbp[i].roots = (uint32)((root1 << 16) | root2);
		if (root2 == 0) fbn[i].roots = 0;
		else fbn[i].roots = (uint32)((prime - root2) << 16);
		if (root1 == 0) fbn[i].roots |= 0;
		else fbn[i].roots |= (uint32)(prime - root1);
	}

    for (i = start_prime; i<fb->B; i++)
	{
		uint64 tmp, t2;

		prime = fb->list->prime[i];
		root1 = modsqrt[i]; 
		root2 = prime - root1; 

		if (prime > 256)
			break;

		bmodp = poly->poly_b % (uint64)prime;
		x = (int)root1 - bmodp;
		if (x < 0) x += prime;
		root1 = x;
		x = (int)root2 - bmodp;
		if (x < 0) x += prime;
		root2 = x;
	
		//now (t - b) mod p is in root1 and (-t - b) mod p is in root2
		//find a^-1 mod p = inv(a mod p) mod p
		amodp = poly->poly_a % (uint64)prime;
		amodp = modinv_1(amodp,prime);

        t2 = (uint64)amodp * (uint64)root1;
        tmp = (((uint64)t2 * (uint64)fb->list->small_inv[i]) >> 32);
        root1 = t2 - tmp * prime;
        if (root1 >= prime) root1 -= prime;

        t2 = (uint64)amodp * (uint64)root2;
        tmp = (((uint64)t2 * (uint64)fb->list->small_inv[i]) >> 32);
        root2 = t2 - tmp * prime;
        if (root2 >= prime) root2 -= prime;

		if (root2 < root1)
		{
			fbp[i].roots = (uint32)((root2 << 16) | root1);
			fbn[i].roots = (uint32)(((prime - root1) << 16) | (prime - root2));
		}
		else
		{
			fbp[i].roots = (uint32)((root1 << 16) | root2);
			fbn[i].roots = (uint32)(((prime - root2) << 16) | (prime - root1));
		}
	}

	for ( ;i<fb->B;i++)
	{
		uint64 tmp, t2;

		prime = fb->list->prime[i];
		root1 = modsqrt[i]; 
		root2 = prime - root1; 

		bmodp = poly->poly_b % (uint64)prime;
		x = (int)root1 - bmodp;
		if (x < 0) x += prime;
		root1 = x;
		x = (int)root2 - bmodp;
		if (x < 0) x += prime;
		root2 = x;
	
		//now (t - b) mod p is in root1 and (-t - b) mod p is in root2
		//find a^-1 mod p = inv(a mod p) mod p
		amodp = poly->poly_a % (uint64)prime;
		amodp = modinv_1(amodp,prime);

        t2 = (uint64)amodp * (uint64)root1;
        tmp = (((uint64)t2 * (uint64)fb->list->small_inv[i]) >> 40);
        root1 = t2 - tmp * prime;
        if (root1 >= prime) root1 -= prime;

        t2 = (uint64)amodp * (uint64)root2;
        tmp = (((uint64)t2 * (uint64)fb->list->small_inv[i]) >> 40);
        root2 = t2 - tmp * prime;
        if (root2 >= prime) root2 -= prime;

		if (root2 < root1)
		{
			fbp[i].roots = (uint32)((root2 << 16) | root1);
			fbn[i].roots = (uint32)(((prime - root1) << 16) | (prime - root2));
		}
		else
		{
			fbp[i].roots = (uint32)((root1 << 16) | root2);
			fbn[i].roots = (uint32)(((prime - root2) << 16) | (prime - root1));
		}
	}
	return;
}

int qcomp_smpqs(const void *x, const void *y)
{
	sm_mpqs_r **xx = (sm_mpqs_r **)x;
	sm_mpqs_r **yy = (sm_mpqs_r **)y;
	
	if (xx[0]->largeprime > yy[0]->largeprime)
		return 1;
	else if (xx[0]->largeprime == yy[0]->largeprime)
		return 0;
	else
		return -1;
}

static uint64 smpqs_bitValRead64(uint64 **m, int row, int col);

int smpqs_BlockGauss(sm_mpqs_rlist *full, sm_mpqs_rlist *partial, uint64 *apoly, uint64 *bpoly,
			fb_list_sm_mpqs *fb, mpz_t n, int mul, 
			mpz_t *factors,uint32 *num_factor)
{
	int i,j,k,l,a,q,polynum;
	int *bl;
	uint8 **m;		//matrix of the powers of the prime decompositions of the relations over the factor base
	uint64 **m2_64;	//m mod 2, packed into 32 bit words
	uint64 **aug_64;	//matrix to store the permutations of the rows of m2, packed into 32 bit words
	uint32 largep, bool_val, B = fb->B;
	uint32 *partial_index;
	int num_f,num_p;
	int num_r,num_col,num_col_aug,set_continue;
	const int blocksz = 64;

	uint32 *pd;
	mpz_t zx, zy, tmp, tmp2, tmp3, tmp4, nn,tmp_a,input,zmul;
	
	mpz_init(zx);
	mpz_init(zy);
	mpz_init(tmp);
	mpz_init(tmp2);
	mpz_init(tmp3);
	mpz_init(tmp4);
	mpz_init(nn);
	mpz_init(input);
	mpz_init(tmp_a);
	mpz_init(zmul);

	num_f = full->num_r;
	num_p = partial->act_r;

	num_r = full->num_r + partial->act_r;
	num_col = (uint32)((B/blocksz)+1);
	num_col_aug = (uint32)(num_r/blocksz+1);

	//allocate storage based on total number of relations.
	pd = (uint32 *)malloc(B * sizeof(uint32));
	partial_index = (uint32 *)malloc(num_p * sizeof(uint32));

	aug_64 = (uint64 **)malloc(num_r * sizeof(uint64 *));
	for (i=0; i<num_r; i++)
		aug_64[i] = (uint64 *)malloc(num_col_aug * sizeof(uint64));

	m2_64 = (uint64 **)malloc(num_r * sizeof(uint64 *));
	for (i=0; i<num_r; i++)
		m2_64[i] = (uint64 *)malloc(num_col * sizeof(uint64));

	m = (uint8 **)malloc(num_r * sizeof(uint8 *));
	for (i=0; i<num_r; i++)
		m[i] = (uint8 *)malloc(B * sizeof(uint8));

	bl = (int *)malloc(num_r * sizeof(int));

	//write fulls to m
	for (i=0;i<num_f;i++)
	{
		//Initialize
		for (j=0;j<(int)B;j++)
			m[i][j] = 0;

		//copy the pd's of the fboffsets to the correct location in m
		//offset 0 is special - indicates the parity of the offset
		m[i][0] = (uint8)full->list[i]->fboffset[0];
		j=1;
		while (j<full->list[i]->num_factors)
		{
			m[i][full->list[i]->fboffset[j]]++;
			j++;
		}
	}

	//write fulls from partials to m, probably also redundant to do it this way?
	largep = partial->list[0]->largeprime;
	j=num_f;
	for (i=1;i<(int)partial->num_r;i++)
	{
		if (partial->list[i]->largeprime == largep)
		{
			//this partial's largep is the same as the one before, add the pd's and copy to m
			for (k=0;k<(int)B;k++)
				m[j][k] = 0;

			//do the factor of -1
			m[j][0] = (uint8)partial->list[i-1]->fboffset[0];
			//then the rest
			k=1;
			while (k<partial->list[i-1]->num_factors) 
			{
				m[j][partial->list[i-1]->fboffset[k]]++;
				k++;
			}
			//factor of -1
			m[j][0] += partial->list[i]->fboffset[0];
			//the rest
			k=1;
			while (k<partial->list[i]->num_factors)
			{
				m[j][partial->list[i]->fboffset[k]]++;
				k++;
			}
			//remember the index of the partial that made this full relation, we'll need it later
			partial_index[j-num_f]=i;
			//increment the relation counter
			j++;
		}
		largep = partial->list[i]->largeprime;
	}

	//construct the bit matrix
	for (i=0;i<num_r;i++)
	{
		for (j=0;j<num_col;j++)
		{
			m2_64[i][j] = 0;
			for (k=0;k<blocksz;k++)
			{
				if ((blocksz*j+k) < (int)B)
					m2_64[i][j] |= ((uint64)((uint64)m[i][blocksz*j+k]%2) << k);
			}
		}
	}

	//construct augmented matrix
	for (i=0;i<num_r;i++)
	{
		for (j=0;j<num_col_aug;j++)
		{
			aug_64[i][j] = 0;
			for (k=0;k<blocksz;k++)
			{
				if ((blocksz*j+k)==i)
					aug_64[i][j] = ((uint64)(1) << (uint64)(k));
			}
		}
	}

	*num_factor=0;

	// remove the multiplier from the input
	mpz_tdiv_q_ui(input, n, mul); //zShortDiv(n,mul,&input);
	mpz_set_ui(zmul, mul); //sp2z(mul,&zmul);

	//initialize blacklist
	for (i=0;i<num_r;i++) bl[i] = 0;
	//search over all columns, right to left (more sparse on the right side)
	for (i=B-1;i>=0;i--)
	{
		//and all rows
		for (j=0;j<num_r;j++)
		{
			//if the j'th row, i'th bit is 1 and not blacklisted, continue
			bool_val = (smpqs_bitValRead64(m2_64,j,i) != 0) && (bl[j] == 0);
			//bool_val = (((m2_64[(j)][(i >> 6)]) & (1ULL << ((uint64)i & 63ULL))) && (bl[j] == 0));
			if (bool_val)
			{
				//add the j'th row mod 2 to all rows after it with a 1 in the ith column
				for (k=j+1;k<num_r;k++)
				{
					bool_val = (smpqs_bitValRead64(m2_64,k,i) != 0) && (bl[k] == 0);
					//bool_val = (((m2_64[(k)][(i >> 6)]) & (1ULL << ((uint64)i & 63ULL))) && (bl[k] == 0));
					if (bool_val)
					{
						//found one in the k'th row.  add to the j'th row starting at column i.
						//record the addition in the augmented matrix
						for (l=(uint32)(i/blocksz);l>=0;l--)
							m2_64[k][l] = m2_64[j][l] ^ m2_64[k][l];
						for (l=0;l<num_col_aug;l++)
							aug_64[k][l] = aug_64[k][l] ^ aug_64[j][l];
						
						//then check if the row is all zeros
						a=0;
						for (l=(uint32)(i/blocksz);l>=0;l--)
							a = a || m2_64[k][l];

						if (a==0)
						{
							//initialize solution vector
							for (l=0;l<(int)B;l++) pd[l] = 0;

							//found a potential solution. check it.
							for (l=0;l<num_r;l++)
							{
								bool_val = smpqs_bitValRead64(aug_64,k,l) != 0;
								//bool_val = (((aug_64[(k)][(l >> 6)]) & (1ULL << ((uint64)l & 63ULL)))) != 0;
								if (bool_val)
								{
									//then the l'th row of m was involved
									for (q=0;q<(int)B;q++)
										pd[q] += m[l][q];
								}
							}

							//compute x mod n
							mpz_set_ui(zy, 1); //sm_zcopy(&zOne,&zy);
							mpz_set_ui(zx, 1); //sm_zcopy(&zOne,&zx);
							for (l=0;l<num_r;l++)
							{
								bool_val = smpqs_bitValRead64(aug_64,k,l) != 0;
								//bool_val = (((aug_64[(k)][(l >> 6)]) & (1ULL << ((uint64)l & 63ULL)))) != 0;
								if (bool_val)
								{
									//printf("accumulating relation %d\n",l);
									//then the l'th relation is involved in the product of relations
									if (l >= num_f)
									{
										uint64 pa;
										uint32 d1,d2;
										//if l >= num_f, then this row refers to a relation generated from two partials.
										//we'll need to go back to the two partial locations to find the two offsets to
										//multiply together
										//luckily, we've remembered the index in the complete list of partials that 
										//created this full relation
											
										//our relation is of the form (ax + b)^2 == a(ax^2 + 2bx + c) mod n
										//(ax^2 + 2bx + c) is what we trial divided, and we remembered
										//a and b, so we can form the left hand side easily
											
										// poly_a and b will fit in a uint64 in smallmpqs

										//recreate poly_b from poly_a (store instead??)
										polynum = partial->list[partial_index[l-num_f]]->polynum;
											
										//compute Q1(x)
										pa = apoly[polynum];
										d1 = (uint32)sqrt((int64)pa);
										
										mpz_set_64(tmp, apoly[polynum]);
										mpz_set_64(tmp3, bpoly[polynum]);
										mpz_mul_ui(tmp, tmp, partial->list[partial_index[l-num_f]]->offset); //zShortMul(&apoly[polynum],partial->list[partial_index[l-num_f]]->offset,&tmp);
										if (partial->list[partial_index[l-num_f]]->parity)
											mpz_sub(tmp, tmp, tmp3); //zShortSub(&tmp,pb,&tmp);
										else
											mpz_add(tmp, tmp, tmp3); //zShortAdd(&tmp,pb,&tmp);

										//include 'a'
										mpz_mul_ui(tmp2, zy, d1); //zShortMul(&zy,d1,&tmp2);
										mpz_tdiv_r(zy, tmp2, n); //zDiv(&tmp2,n,&tmp3,&zy);

										//compute Q2(x)
										polynum = partial->list[partial_index[l-num_f]-1]->polynum;
											
										//compute Q1(x)
										pa = apoly[polynum]; 
										d2 = (uint32)sqrt((int64)pa);
										
										mpz_set_64(tmp3, apoly[polynum]);
										mpz_set_64(tmp4, bpoly[polynum]);
										mpz_mul_ui(tmp3, tmp3, partial->list[partial_index[l-num_f]-1]->offset); //zShortMul(&apoly[polynum],partial->list[partial_index[l-num_f]-1]->offset,&tmp3);
										if (partial->list[partial_index[l-num_f]-1]->parity)
											mpz_sub(tmp2, tmp3, tmp4); //zShortSub(&tmp3,pb,&tmp2);
										else
											mpz_add(tmp2, tmp3, tmp4); //zShortAdd(&tmp3,pb,&tmp2);

										//compute Q(x1)*Q(x2)
										mpz_mul(tmp4, tmp, tmp2); //zMul(&tmp,&tmp2,&tmp4);	
										mpz_mul(tmp, zx, tmp4); //zMul(&zx,&tmp4,&tmp);		//accumulate with previous terms
										mpz_tdiv_r(zx, tmp, n); //zDiv(&tmp,n,&tmp2,&zx);		//mod n

										//include the large prime in mp_y
										mpz_mul_ui(tmp2, zy, partial->list[partial_index[l-num_f]]->largeprime); //zShortMul(&zy,partial->list[partial_index[l-num_f]]->largeprime,&tmp2);
										mpz_tdiv_r(zy, tmp2, n); //zDiv(&tmp2,n,&tmp3,&zy);

										//include 'a'
										mpz_mul_ui(tmp2, zy, d2); //zShortMul(&zy,d2,&tmp2);	
										mpz_tdiv_r(zy, tmp2, n); //zDiv(&tmp2,n,&tmp3,&zy);
									}
									else
									{
										uint64 pa,d1;

										//recreate poly_b from poly_a (store instead??)
										polynum = full->list[l]->polynum;
											
										//compute Q1(x)
										mpz_set_64(tmp, apoly[polynum]);
										mpz_set_64(tmp4, bpoly[polynum]);
										mpz_mul_ui(tmp, tmp, full->list[l]->offset); //zShortMul(&apoly[polynum],full->list[l]->offset,&tmp);
										pa = apoly[polynum]; //apoly[polynum].val[0];
										d1 = (uint32)sqrt((int64)pa);

										if (full->list[l]->parity)
											mpz_sub(nn, tmp, tmp4); //zShortSub(&tmp,pb,&nn);
										else
											mpz_add(nn, tmp, tmp4); //zShortAdd(&tmp,pb,&nn);

										mpz_mul(tmp, zx, nn); //zMul(&zx,&nn,&tmp);			//accumulate with previous terms
										mpz_tdiv_r(zx, tmp, n); //zDiv(&tmp,n,&tmp2,&zx);		//mod n

										mpz_mul_ui(tmp2, zy, d1); //zShortMul(&zy,d1,&tmp2);	//sqrt(a) = d is part of mp_y
										mpz_tdiv_r(zy, tmp2, n); //zDiv(&tmp2,n,&tmp3,&zy);
									}
								}
							}

							//compute y mod n
							//ignore the factor of -1 in this operation
							for (l=1;l<(int)B;l++)
							{
								if (pd[l] > 0)
								{
									mpz_set_ui(tmp, fb->list->prime[l]); //sp2z(fb->list->prime[l],&tmp);
									//pd tracks the exponents of the smooth factors.  we know they are all even
									//at this point.  we don't want to compute pd^2, so divide by 2.
									//computing the explicit exponentiation and then reducing is
									//slightly faster than doing modexp in smallmpqs.
									//zExp(pd[l]/2,&tmp,&tmp2);
									//zDiv(&tmp2,n,&tmp4,&tmp3);
									mpz_powm_ui(tmp3, tmp, pd[l] / 2, n);
									mpz_mul(tmp4, tmp3, zy); //zMul(&tmp3,&zy,&tmp4);
									mpz_tdiv_r(zy, tmp4, n); //zDiv(&tmp4,n,&tmp2,&zy);
								}
							}

							//split this off into a subroutine... also look for all non-trivial factors if one is composite
							//compute gcd(x-y,n)
							mpz_sub(tmp, zx, zy); //zSub(&zx,&zy,&tmp);
							mpz_gcd(nn, tmp, n); //zLEGCD(&tmp,n,&nn);

							//gmp_printf("gcd is %Zd\n",nn);
							
							/* remove any factors of the multiplier 
							   before saving tmp, and don't save at all
							   if tmp contains *only* multiplier factors */
							if (mul > 1) {
								uint32 ignore_me = spGCD(mul,
										mpz_tdiv_ui(nn, mul)); //zShortMod(&nn, mul));
								if (ignore_me > 1) {
									mpz_tdiv_q_ui(nn, nn, ignore_me); //zShortDiv(&nn, ignore_me, &tmp2);
									if (mpz_cmp_ui(nn, 1) == 0)
										continue;
								}								
							}								

							
							if ((mpz_cmp_ui(nn, 1) > 0) && (mpz_cmp(nn,input) < 0))
							{

								//gmp_printf("checking factor %Zd\n",nn);
								if (mpz_probab_prime_p(nn,5))
								{

									// sometime we find small primes that don't divide the input.
									// ignore these
									if (mpz_sizeinbase(nn,2) < 32)
									{
										if (mpz_tdiv_ui(input, mpz_get_ui(nn)) != 0)
											continue;

										//if (zShortMod(&input,nn.val[0]) != 0)
											//continue;
									}

									//check that we havent' already found this one
									set_continue = 0;
									for (l=0;l<(int)*num_factor;l++)
									{
										if (mpz_cmp(nn,factors[l]) == 0)
											set_continue = 1;
									}
									if (set_continue)
										continue;

									mpz_set(factors[*num_factor],nn);

									(*num_factor)++;
									if (*num_factor > MAX_FACTORS)
									{
										printf("max number of factors found in block gauss\n");
										goto free;
									}

									//check if we're done by accumulating all factors and comparing to n
									mpz_set(nn,factors[0]);
									for (l=1;l<(int)*num_factor;l++)
										mpz_mul(nn,factors[l],nn); //,&nn);
									if (mpz_cmp(nn,input) == 0)
									{
										//found all factors, done
										goto free;
									}
								}

								//check the other factor
								//sm_zcopy(&input,&tmp);
								//zDiv(&tmp,&nn,&tmp2,&tmp3);
								//sm_zcopy(&tmp2,&tmp);
								
								mpz_tdiv_q(tmp, input, nn);								
	
								//gmp_printf("checking factor %Zd\n",tmp);
								if (mpz_probab_prime_p(tmp,5))
								{
									// sometime we find small primes that don't divide the input.
									// ignore these
									if (mpz_sizeinbase(nn,2) < 32)
									{
										if (mpz_tdiv_ui(input, mpz_get_ui(tmp)) != 0)
											continue;

										//if (zShortMod(&input,nn.val[0]) != 0)
											//continue;
									}

									//check that we havent' already found this one
									set_continue = 0;
									for (l=0;l<(int)*num_factor;l++)
									{
										if (mpz_cmp(tmp,factors[l]) == 0)
											set_continue = 1;
									}
									if (set_continue)
										continue;

									mpz_set(factors[*num_factor],tmp);

									(*num_factor)++;
									if (*num_factor > MAX_FACTORS)
									{
										printf("max number of factors found in block gauss\n");
										goto free;
									}

									//check if we're done by accumulating all factors and comparing to n
									mpz_set(tmp,factors[0]);
									for (l=1;l<(int)*num_factor;l++)
										mpz_mul(tmp,factors[l],tmp); //,&nn);
									if (mpz_cmp(tmp,input) == 0)
									{
										//found all factors, done
										goto free;
									}
								}
							} //if non-trivial factor
						} //if a == 0
					} //if found in k'th row
				} //add jth row mod 2 to all appropriate rows after it
				//blacklist the j'th row
				bl[j] = 1;
			} //if not blacklisted
		} //for all rows
	} //for all columns

	//printf("matrix exhausted\n");
	mpz_tdiv_q_ui(tmp, n, mul);
	for (i=0;(uint32)i<*num_factor;i++)
	{
		//sm_zcopy(&tmp,&nn);
		//zDiv(&nn,&factors[i],&tmp,&tmp2);
		mpz_tdiv_q(tmp, tmp, factors[i]);
	}

free:
	free(pd);
	free(partial_index);
	for (i=0; i<num_r; i++)
		free(aug_64[i]);
	free(aug_64);
	for (i=0; i<num_r; i++)
		free(m2_64[i]);
	free(m2_64);
	for (i=0; i<num_r; i++)
		free(m[i]);
	free(m);

	free(bl);
	mpz_clear(zx);
	mpz_clear(zy);
	mpz_clear(tmp);
	mpz_clear(tmp2);
	mpz_clear(tmp3);
	mpz_clear(tmp4);
	mpz_clear(nn);
	mpz_clear(tmp_a);
	mpz_clear(input);
	mpz_clear(zmul);
	return 0;
}

static uint64 smpqs_masks64[64] = {0x1,0x2,0x4,0x8,
							0x10,0x20,0x40,0x80,
							0x100,0x200,0x400,0x800,
							0x1000,0x2000,0x4000,0x8000,
							0x10000,0x20000,0x40000,0x80000,
							0x100000,0x200000,0x400000,0x800000,
							0x1000000,0x2000000,0x4000000,0x8000000,
							0x10000000,0x20000000,0x40000000,0x80000000ULL,
							0x100000000ULL,0x200000000ULL,0x400000000ULL,0x800000000ULL,
							0x1000000000ULL,0x2000000000ULL,0x4000000000ULL,0x8000000000ULL,
							0x10000000000ULL,0x20000000000ULL,0x40000000000ULL,0x80000000000ULL,
							0x100000000000ULL,0x200000000000ULL,0x400000000000ULL,0x800000000000ULL,
							0x1000000000000ULL,0x2000000000000ULL,0x4000000000000ULL,0x8000000000000ULL,
							0x10000000000000ULL,0x20000000000000ULL,0x40000000000000ULL,0x80000000000000ULL,
							0x100000000000000ULL,0x200000000000000ULL,0x400000000000000ULL,0x800000000000000ULL,
							0x1000000000000000ULL,0x2000000000000000ULL,0x4000000000000000ULL,0x8000000000000000ULL};



static uint64 smpqs_bitValRead64(uint64 **m, int row, int col)
{
	//col is the column in 0 to B-1 representation
	//read the bit in the packed 64 bit representation of the appropriate row
	//don't bother to check the bounds of m w.r.t row and col, assume caller knows what it's doing
	//return 0 if bit not set, 1 << bit offset otherwize
	int offset, mcol;
	mcol = col >> 6;
	offset = col & 63;
	return (m[row][mcol] & smpqs_masks64[offset]);
}





